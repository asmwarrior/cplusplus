// Copyright (c) 2020 Roberto Raggi <roberto.raggi@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

%class Parser

%token-type TokenKind

%{
  struct DeclSpecs {
    bool has_simple_typespec = false;
    bool has_complex_typespec = false;
    bool has_named_typespec = false;
    bool has_placeholder_typespec = false;
    bool no_typespecs = false;

    bool accepts_simple_typespec() const {
      return !(has_complex_typespec
        || has_named_typespec
        || has_placeholder_typespec);
    }

    bool has_typespec() const {
      return has_simple_typespec
        || has_complex_typespec
        || has_named_typespec
        || has_placeholder_typespec;
    }
  };

  struct TemplArgContext {
    TemplArgContext(const TemplArgContext&) = delete;
    TemplArgContext& operator=(const TemplArgContext&) = delete;

    Parser* p;

    explicit TemplArgContext(Parser* p): p(p) { ++p->templArgDepth; }
    ~TemplArgContext() { --p->templArgDepth; }
  };

  int templArgDepth = 0;

  bool yyparse(TranslationUnit* unit,
    const std::function<void(TranslationUnitAST*)>& consume);

  TranslationUnit* unit = nullptr;
  Arena* pool = nullptr;
  Control* control = nullptr;
  bool skip_function_body = true;
%}

%token
  eof
, error
, identifier
, character_literal
, floating_point_literal
, integer_literal
, string_literal
, user_defined_literal
, user_defined_string_literal

// operators and punctuators

, exclaim
, exclaim_equal
, percent
, percent_equal
, amp
, amp_amp
, amp_equal
, lparen
, rparen
, star
, star_equal
, plus
, plus_plus
, plus_equal
, comma
, minus
, minus_minus
, minus_equal
, minus_greater
, minus_greater_star
, dot
, dot_star
, dot_dot_dot
, slash
, slash_equal
, colon
, colon_colon
, semicolon
, less
, less_less
, less_less_equal
, less_equal
, less_equal_greater
, equal
, equal_equal
, greater
, question
, lbracket
, rbracket
, caret
, caret_equal
, lbrace
, bar
, bar_equal
, bar_bar
, rbrace
, tilde

// keywords

, __alignof
, __asm
, __asm__
, __attribute
, __attribute__
, __extension__
, __has_unique_object_representations
, __has_virtual_destructor
, __inline
, __inline__
, __is_abstract
, __is_aggregate
, __is_base_of
, __is_class
, __is_constructible
, __is_convertible_to
, __is_empty
, __is_enum
, __is_final
, __is_function
, __is_literal
, __is_nothrow_assignable
, __is_nothrow_constructible
, __is_pod
, __is_polymorphic
, __is_same
, __is_standard_layout
, __is_trivial
, __is_trivially_assignable
, __is_trivially_constructible
, __is_trivially_copyable
, __is_trivially_destructible
, __is_union
, __reference_binds_to_temporary
, __restrict
, __underlying_type
, _Atomic

, alignas
, alignof
, asm
, auto
, bool
, break
, case
, catch
, char
, char16_t
, char32_t
, char8_t
, class
, co_await
, co_return
, co_yield
, concept
, const
, const_cast
, consteval
, constexpr
, constinit
, continue
, decltype
, default
, delete
, do
, double
, dynamic_cast
, else
, enum
, explicit
, export
, extern
, false
, float
, for
, friend
, goto
, if
, inline
, int
, long
, mutable
, namespace
, new
, noexcept
, nullptr
, operator
, private
, protected
, public
, reinterpret_cast
, requires
, return
, short
, signed
, sizeof
, static
, static_assert
, static_cast
, struct
, switch
, template
, this
, thread_local
, throw
, true
, try
, typedef
, typeid
, typename
, union
, unsigned
, using
, virtual
, void
, volatile
, wchar_t
, while

warn(const char* s): { unit->warning(yycursor, "%s", s); };

id(const std::string_view& name): identifier
{
  return unit->identifier(yycursor - 1)->string() == name;
};

nospace:
{
  const auto& tk = unit->tokenAt(yycursor);
  return !tk.leadingSpace() && !tk.startOfLine();
};

greater_greater
: greater_greater_equal { return false; }
| greater nospace greater;

greater_greater_equal: greater nospace greater nospace equal;

greater_equal: greater nospace equal;

header_name: { return false; };

export_keyword: at_start_of_line export;
import_keyword: at_start_of_line id("import");
module_keyword: at_start_of_line id("module");
final: id("final");
override: id("override");

at_start_of_line: { return unit->tokenAt(yycursor).startOfLine(); };

typedef_name
: simple_template_id
| identifier
;

namespace_name
: identifier
| namespace_alias
;

namespace_alias
: identifier
;

class_name
: simple_template_id
| identifier
;

enum_name
: identifier
;

template_name
: identifier
;

literal
: integer_literal
| character_literal
| floating_point_literal
| string_literal
| boolean_literal
| pointer_literal
| user_defined_literal
;

boolean_literal
: false
| true
;

pointer_literal
: nullptr
;

translation_unit
: global_module_fragment? module_declaration declaration_seq? private_module_fragment?
| declaration_seq?
;

declaration_seq: declaration+;

primary_expression
: literal
| this
| lparen expression rparen
| id_expression
| lambda_expression
| fold_expression
| requires_expression
;

id_expression
: qualified_id
| unqualified_id
;

unqualified_id
: template_id
| tilde type_name
| tilde decltype_specifier
| identifier
| operator_function_id
| conversion_function_id
| literal_operator_id
;

qualified_id
: nested_name_specifier template? unqualified_id
;

nested_name_specifier
: (colon_colon
  | type_name colon_colon
  | namespace_name colon_colon
  | decltype_specifier colon_colon)
      ( template? simple_template_id colon_colon
      | identifier colon_colon)*
;

lambda_expression
: lambda_introducer less template_parameter_list greater requires_clause? lambda_declarator? compound_statement
| lambda_introducer lambda_declarator? compound_statement
;

lambda_introducer
: lbracket lambda_capture? rbracket
;

lambda_declarator
: lparen parameter_declaration_clause rparen decl_specifier_seq? noexcept_specifier? attribute_specifier_seq? trailing_return_type? requires_clause?
;

lambda_capture
: capture_default (comma capture_list)*
| capture_list
;

capture_default
: amp
| equal
;

capture_list
: capture (comma capture)*
;

capture
: init_capture
| simple_capture
;

simple_capture
: identifier dot_dot_dot?
| amp identifier dot_dot_dot?
| this
| star this
;

init_capture
: dot_dot_dot? identifier initializer
| amp dot_dot_dot? identifier initializer
;

fold_expression
: lparen cast_expression fold_operator dot_dot_dot rparen
| lparen dot_dot_dot fold_operator cast_expression rparen
| lparen cast_expression fold_operator dot_dot_dot fold_operator cast_expression rparen
;

fold_operator
: plus
| minus
| star
| slash
| percent
| caret
| amp
| bar
| less_less
| plus_equal
| minus_equal
| star_equal
| slash_equal
| percent_equal
| caret_equal
| amp_equal
| bar_equal
| less_less_equal
| greater_greater_equal
| greater_greater
| greater_equal
| greater
| equal
| equal_equal
| exclaim_equal
| less
| less_equal
| amp_amp
| bar_bar
| comma
| dot_star
| minus_greater_star
;

requires_expression
: requires requirement_parameter_list? requirement_body
;

requirement_parameter_list
: lparen parameter_declaration_clause? rparen
;

requirement_body
: lbrace requirement_seq rbrace
;

requirement_seq: requirement+;

requirement
: simple_requirement
| type_requirement
| compound_requirement
| nested_requirement
;

simple_requirement
: expression semicolon
;

type_requirement
: typename nested_name_specifier? type_name semicolon
;

compound_requirement
: lbrace expression rbrace noexcept? return_type_requirement? semicolon
;

return_type_requirement
: minus_greater type_constraint
;

nested_requirement
: requires constraint_expression semicolon
;

postfix_expression
{
  DeclSpecs specs;
}
: ( const_cast less type_id greater lparen expression rparen
  | dynamic_cast less type_id greater lparen expression rparen
  | reinterpret_cast less type_id greater lparen expression rparen
  | simple_type_specifier(specs) ( braced_init_list
                                 | lparen expression_list? rparen)
  | static_cast less type_id greater lparen expression rparen
  | typeid lparen expression rparen
  | typeid lparen type_id rparen
  | typename_specifier braced_init_list
  | typename_specifier lparen expression_list? rparen
  | __has_unique_object_representations lparen type_id rparen
  | __has_virtual_destructor lparen type_id rparen
  | __is_abstract lparen type_id rparen
  | __is_aggregate lparen type_id rparen
  | __is_base_of lparen type_id comma type_id rparen
  | __is_class lparen type_id rparen
  | __is_constructible lparen type_id comma type_id rparen
  | __is_convertible_to lparen type_id comma type_id rparen
  | __is_empty lparen type_id rparen
  | __is_enum lparen type_id rparen
  | __is_final lparen type_id rparen
  | __is_function lparen type_id rparen
  | __is_nothrow_assignable lparen type_id comma type_id rparen
  | __is_nothrow_constructible lparen type_id comma type_id rparen
  | __is_pod lparen type_id rparen
  | __is_polymorphic lparen type_id rparen
  | __is_same lparen type_id comma type_id rparen
  | __is_standard_layout lparen type_id rparen
  | __is_trivial lparen type_id rparen
  | __is_trivially_assignable lparen type_id comma type_id rparen
  | __is_trivially_constructible lparen type_id comma type_id rparen
  | __is_trivially_copyable lparen type_id rparen
  | __is_trivially_destructible lparen type_id rparen
  | __is_union lparen type_id rparen
  | __reference_binds_to_temporary lparen type_id comma type_id rparen
  | primary_expression)
    ( dot template? id_expression
    | lbracket expr_or_braced_init_list rbracket
    | lparen expression_list? rparen
    | minus_greater template? id_expression
    | minus_minus
    | plus_plus)*
;

expression_list
: initializer_list
;

unary_expression
: unary_operator cast_expression
| plus_plus cast_expression
| minus_minus cast_expression
| await_expression
| sizeof unary_expression
| sizeof lparen type_id rparen
| sizeof dot_dot_dot lparen identifier rparen
| alignof lparen type_id rparen
| __alignof lparen type_id rparen
| noexcept_expression
| new_expression
| delete_expression
| postfix_expression
;

unary_operator
: star
| amp
| plus
| minus
| exclaim
| tilde
;

await_expression
: co_await cast_expression
;

noexcept_expression
: noexcept lparen expression rparen
;

new_expression
: colon_colon? new new_placement? new_type_id new_initializer?
| colon_colon? new new_placement? lparen type_id rparen new_initializer?
;

new_placement
: lparen expression_list rparen
;

new_type_id
: type_specifier_seq new_declarator?
;

new_declarator
: ptr_operator new_declarator?
| noptr_new_declarator
;

noptr_new_declarator
: lbracket expression? rbracket attribute_specifier_seq? (lbracket constant_expression rbracket attribute_specifier_seq?)*
;

new_initializer
: lparen expression_list? rparen
| braced_init_list
;

delete_expression
: colon_colon? delete cast_expression
| colon_colon? delete lbracket rbracket cast_expression
;

cast_expression
: lparen type_id rparen cast_expression
| unary_expression
;

pm_expression
: cast_expression ((dot_star | minus_greater_star) cast_expression)*
;

multiplicative_expression
: pm_expression ((star | slash | percent) pm_expression)*
;

additive_expression
: multiplicative_expression ((plus | minus) multiplicative_expression)*
;

shift_expression(bool templArg)
: additive_expression
    ((less_less | { if (templArg && templArgDepth >= 2) return false; } greater_greater)
      additive_expression)*
;

compare_expression(bool templArg)
: shift_expression(templArg) (less_equal_greater shift_expression(templArg))*
;

relational_expression(bool templArg)
: compare_expression(templArg) ((less_equal | greater_equal | less | { return !templArg; } greater) compare_expression(templArg))*
;

equality_expression(bool templArg)
: relational_expression(templArg) ((equal_equal | exclaim_equal) relational_expression(templArg))*
;

and_expression(bool templArg)
: equality_expression(templArg) (amp equality_expression(templArg))*
;

exclusive_or_expression(bool templArg)
: and_expression(templArg) (caret and_expression(templArg))*
;

inclusive_or_expression(bool templArg)
: exclusive_or_expression(templArg) (bar exclusive_or_expression(templArg))*
;

logical_and_expression(bool templArg)
: inclusive_or_expression(templArg) (amp_amp inclusive_or_expression(templArg))*
;

logical_or_expression(bool templArg)
: logical_and_expression(templArg) (bar_bar logical_and_expression(templArg))*
;

conditional_expression(bool templArg)
: logical_or_expression(templArg) (question expression colon assignment_expression)?
;

yield_expression
: co_yield assignment_expression
| co_yield braced_init_list
;

throw_expression
: throw assignment_expression?
;

assignment_expression
: yield_expression
| throw_expression
| logical_or_expression(false) assignment_operator initializer_clause
| conditional_expression(false)
;

assignment_operator
: equal
| star_equal
| slash_equal
| percent_equal
| plus_equal
| minus_equal
| greater_greater_equal
| less_less_equal
| amp_equal
| caret_equal
| bar_equal
;

expression
: assignment_expression (comma assignment_expression)*
;

constant_expression
: conditional_expression(false)
;

template_argument_constant_expression
: conditional_expression(true)
;

statement
: __extension__ statement
| labeled_statement
| attribute_specifier_seq? expression_statement
| attribute_specifier_seq? compound_statement
| attribute_specifier_seq? selection_statement
| attribute_specifier_seq? iteration_statement
| attribute_specifier_seq? jump_statement
| attribute_specifier_seq? try_block
| declaration_statement
;

init_statement
: simple_declaration
| expression_statement
;

condition
: attribute_specifier_seq? decl_specifier_seq declarator brace_or_equal_initializer
| expression
;

labeled_statement
: attribute_specifier_seq? identifier colon statement
| attribute_specifier_seq? case constant_expression colon statement
| attribute_specifier_seq? default colon statement
;

expression_statement
: expression? semicolon
;

compound_statement
: lbrace statement_seq? rbrace
;

statement_seq: statement+;

selection_statement
: if constexpr? lparen init_statement? condition rparen statement (else statement)?
| switch lparen init_statement? condition rparen statement
;

iteration_statement
: while lparen condition rparen statement
| do statement while lparen expression rparen semicolon
| for lparen init_statement condition? semicolon expression? rparen statement
| for lparen init_statement? for_range_declaration colon for_range_initializer rparen statement
;

for_range_declaration
: attribute_specifier_seq? decl_specifier_seq ref_qualifier? lbracket identifier_list rbracket
| attribute_specifier_seq? decl_specifier_seq declarator
;

for_range_initializer
: expr_or_braced_init_list
;

jump_statement
: break semicolon
| continue semicolon
| return expr_or_braced_init_list? semicolon
| coroutine_return_statement
| goto identifier semicolon
;

coroutine_return_statement
: co_return expr_or_braced_init_list? semicolon
;

declaration_statement
: block_declaration
;

declaration
: block_declaration
| nodeclspec_function_declaration
| function_definition
| template_declaration
| deduction_guide
| explicit_instantiation
| explicit_specialization
| export_declaration
| linkage_specification
| namespace_definition
| empty_declaration
| attribute_declaration
| module_import_declaration
;

block_declaration
: simple_declaration
| asm_declaration
| namespace_alias_definition
| using_declaration
| using_enum_declaration
| using_directive
| static_assert_declaration
| alias_declaration
| opaque_enum_declaration
;

nodeclspec_function_declaration
: attribute_specifier_seq? declarator semicolon
;

alias_declaration
: using identifier attribute_specifier_seq? equal defining_type_id semicolon
;

simple_declaration
: __extension__? attribute_specifier_seq? decl_specifier_seq ref_qualifier? lbracket identifier_list rbracket initializer semicolon
| __extension__? attribute_specifier_seq? decl_specifier_seq_no_typespecs? declarator_id attribute_specifier_seq? parameters_and_qualifiers semicolon
| __extension__? attribute_specifier_seq decl_specifier_seq init_declarator_list semicolon
| __extension__? decl_specifier_seq? init_declarator_list? semicolon
;

static_assert_declaration
: static_assert lparen constant_expression rparen semicolon
| static_assert lparen constant_expression comma string_literal_seq rparen semicolon
;

string_literal_seq: string_literal+;

empty_declaration
: semicolon
;

attribute_declaration
: attribute_specifier_seq semicolon
;

decl_specifier(DeclSpecs& specs)
: storage_class_specifier
| { return !specs.no_typespecs; } defining_type_specifier(specs)
| function_specifier
| friend
| typedef
| constexpr
| consteval
| constinit
| inline
| __inline
| __inline__
;

decl_specifier_seq
{
  DeclSpecs specs;
}
: (decl_specifier(specs) attribute_specifier_seq?)+
;

decl_specifier_seq_no_typespecs
{
  DeclSpecs specs;
  specs.no_typespecs = true;
}
: (decl_specifier(specs) attribute_specifier_seq?)+
;

storage_class_specifier
: static
| thread_local
| extern
| mutable
;

function_specifier
: virtual
| explicit_specifier
;

explicit_specifier
: explicit lparen constant_expression rparen
| explicit
;

type_specifier(DeclSpecs& specs)
: simple_type_specifier(specs)
| elaborated_type_specifier(specs)
| typename_specifier { specs.has_named_typespec = true; }
| cv_qualifier
;

type_specifier_seq
{
  DeclSpecs specs;
}
: (type_specifier(specs) attribute_specifier_seq?)+
;

defining_type_specifier(DeclSpecs& specs)
: class_specifier { specs.has_complex_typespec = true; }
| enum_specifier  { specs.has_complex_typespec = true; }
| type_specifier(specs)
;

defining_type_specifier_seq
{
  DeclSpecs specs;
}
: defining_type_specifier(specs)+ attribute_specifier_seq?
;

simple_type_specifier(DeclSpecs& specs)
: { return !specs.has_typespec(); }
  ( nested_name_specifier ( template simple_template_id
                          | type_name
                          | template_name)
  | type_name
  | template_name) { specs.has_named_typespec = true; }

| { return !specs.has_typespec(); }
  placeholder_type_specifier { specs.has_placeholder_typespec = true; }

| { return !specs.has_typespec(); }
  decltype_specifier { specs.has_placeholder_typespec = true; }

| { return !specs.has_typespec(); }
  __underlying_type lparen type_id rparen
  { specs.has_named_typespec = true; }

| { return specs.accepts_simple_typespec(); }
  _Atomic lparen type_id rparen

| { return specs.accepts_simple_typespec(); }
  ( char
  | char8_t
  | char16_t
  | char32_t
  | wchar_t
  | bool
  | short
  | int
  | long
  | signed
  | unsigned
  | float
  | double
  | void) { specs.has_simple_typespec = true; }
;

type_name
: class_name
| enum_name
| typedef_name
;

elaborated_type_specifier(DeclSpecs& specs)
: class_key attribute_specifier_seq? nested_name_specifier template? simple_template_id
  { specs.has_complex_typespec = true; }
| class_key attribute_specifier_seq? simple_template_id
  { specs.has_complex_typespec = true; }
| class_key attribute_specifier_seq? nested_name_specifier? identifier
  { specs.has_complex_typespec = true; }
| elaborated_enum_specifier
  { specs.has_complex_typespec = true; }
;

elaborated_enum_specifier
: enum nested_name_specifier? identifier
;

decltype_specifier
: decltype lparen expression rparen
;

placeholder_type_specifier
: type_constraint? auto
| type_constraint? decltype lparen auto rparen
;

init_declarator_list
: init_declarator (comma init_declarator)*
;

init_declarator
: declarator requires_clause
| declarator initializer?
;

declarator
: core_declarator parameters_and_qualifiers trailing_return_type
| ptr_declarator
;

ptr_declarator
: ptr_operator_seq? noptr_declarator
;

ptr_operator_seq: ptr_operator+;

core_declarator
: declarator_id attribute_specifier_seq?
| lparen ptr_declarator rparen
;

noptr_declarator
: core_declarator
    ( parameters_and_qualifiers
    | lbracket constant_expression? rbracket attribute_specifier_seq?)*
;

parameters_and_qualifiers
: lparen parameter_declaration_clause rparen cv_qualifier_seq? ref_qualifier? noexcept_specifier? attribute_specifier_seq?
;

cv_qualifier_seq: cv_qualifier+;

trailing_return_type
: minus_greater type_id
;

ptr_operator
: star attribute_specifier_seq? cv_qualifier_seq?
| amp attribute_specifier_seq?
| amp_amp attribute_specifier_seq?
| nested_name_specifier star attribute_specifier_seq? cv_qualifier_seq?
;

cv_qualifier
: const
| volatile
| __restrict
;

ref_qualifier
: amp
| amp_amp
;

declarator_id
: dot_dot_dot? id_expression
;

type_id
: type_specifier_seq abstract_declarator?
;

defining_type_id
: defining_type_specifier_seq abstract_declarator?
;

abstract_declarator
: noptr_abstract_declarator? parameters_and_qualifiers trailing_return_type
| abstract_pack_declarator
| ptr_abstract_declarator
;

ptr_abstract_declarator
: ptr_operator_seq? noptr_abstract_declarator
;

noptr_abstract_declarator
: (lparen ptr_abstract_declarator rparen)?
    ( parameters_and_qualifiers
    | lbracket constant_expression? rbracket attribute_specifier_seq?)*
;

abstract_pack_declarator
: ptr_operator_seq? noptr_abstract_pack_declarator
;

noptr_abstract_pack_declarator
: dot_dot_dot
    ( parameters_and_qualifiers
    | lbracket constant_expression? rbracket attribute_specifier_seq?)*
;

parameter_declaration_clause
: parameter_declaration_list comma dot_dot_dot?
| parameter_declaration_list? dot_dot_dot?
;

parameter_declaration_list
: parameter_declaration (comma parameter_declaration)*
;

parameter_declaration
: attribute_specifier_seq? decl_specifier_seq declarator (equal initializer_clause)?
| attribute_specifier_seq? decl_specifier_seq abstract_declarator? (equal initializer_clause)?
;

initializer
: brace_or_equal_initializer
| lparen expression_list rparen
;

brace_or_equal_initializer
: equal initializer_clause
| braced_init_list
;

initializer_clause
: braced_init_list
| assignment_expression
;

braced_init_list
: lbrace initializer_list comma? rbrace
| lbrace designated_initializer_list comma? rbrace
| lbrace rbrace
;

initializer_list
: initializer_clause dot_dot_dot? (comma initializer_clause dot_dot_dot?)*
;

designated_initializer_list
: designated_initializer_clause (comma designated_initializer_clause)*
;

designated_initializer_clause
: designator brace_or_equal_initializer
;

designator
: dot identifier
;

expr_or_braced_init_list
: expression
| braced_init_list
;

function_definition
: __extension__? attribute_specifier_seq? decl_specifier_seq_no_typespecs? declarator_id attribute_specifier_seq? parameters_and_qualifiers requires_clause function_body
| __extension__? attribute_specifier_seq? decl_specifier_seq_no_typespecs? declarator_id attribute_specifier_seq? parameters_and_qualifiers virt_specifier_seq? function_body
| __extension__? attribute_specifier_seq? decl_specifier_seq? declarator requires_clause function_body
| __extension__? attribute_specifier_seq? decl_specifier_seq? declarator virt_specifier_seq? function_body
;

virt_specifier_seq: virt_specifier+;

function_body
: { return skip_function_body; }
  ctor_initializer? lbrace
    {
      int depth = 1;
      TokenKind tok;
      while ((tok = yytoken()) != TokenKind::T_EOF_SYMBOL) {
        if (tok == TokenKind::T_LBRACE) {
          ++depth;
        } else if (tok == TokenKind::T_RBRACE) {
          if (!--depth) {
            break;
          }
        }
        yyconsume();
      }
    }
  rbrace
| ctor_initializer? compound_statement
| function_try_block
| equal default semicolon
| equal delete semicolon
;

enum_specifier
: enum_head lbrace enumerator_list? rbrace
| enum_head lbrace enumerator_list comma rbrace
;

enum_head
: enum_key attribute_specifier_seq? enum_head_name? enum_base?
;

enum_head_name
: nested_name_specifier? identifier
;

opaque_enum_declaration
: enum_key attribute_specifier_seq? enum_head_name enum_base? semicolon
;

enum_key
: enum class
| enum struct
| enum
;

enum_base
: colon type_specifier_seq
;

enumerator_list
: enumerator_definition (comma enumerator_definition)*
;

enumerator_definition
: enumerator (equal constant_expression)*
;

enumerator
: identifier attribute_specifier_seq?
;

using_enum_declaration
: using elaborated_enum_specifier semicolon
;

namespace_definition
: nested_namespace_definition
| named_namespace_definition
| unnamed_namespace_definition
;

named_namespace_definition
: inline? namespace attribute_specifier_seq? identifier lbrace namespace_body rbrace
;

unnamed_namespace_definition
: inline? namespace attribute_specifier_seq? lbrace namespace_body rbrace
;

nested_namespace_definition
: namespace enclosing_namespace_specifier colon_colon inline? identifier lbrace namespace_body rbrace
;

enclosing_namespace_specifier
: identifier (colon_colon inline? identifier / (colon_colon inline? identifier))*
;

namespace_body
: declaration_seq?
;

namespace_alias_definition
: namespace identifier equal qualified_namespace_specifier semicolon
;

qualified_namespace_specifier
: nested_name_specifier? namespace_name
;

using_directive
: attribute_specifier_seq? using namespace nested_name_specifier? namespace_name semicolon
;

using_declaration
: using using_declarator_list semicolon
;

using_declarator_list
: using_declarator dot_dot_dot? (comma using_declarator dot_dot_dot?)*
;

using_declarator
: typename? nested_name_specifier unqualified_id
;

asm_declaration
: attribute_specifier_seq? asm lparen string_literal rparen semicolon
;

linkage_specification
: extern string_literal lbrace declaration_seq? rbrace
| extern string_literal declaration
;

attribute_specifier_seq
: attribute_specifier+
;

attribute_specifier
: (__attribute | __attribute__) lparen skip_balanced rparen
| lbracket lbracket attribute_using_prefix? attribute_list rbracket rbracket
| alignment_specifier
| (__asm | __asm__) lparen string_literal_seq rparen
;

skip_balanced
: {
  int count = 1;
  TokenKind tk;
  while ((tk = yytoken()) != TokenKind::T_EOF_SYMBOL) {
    if (tk == TokenKind::T_LPAREN) {
      ++count;
    } else if (tk == TokenKind::T_RPAREN) {
      if (!--count) {
        return true;
      }
    }
    yyconsume();
  }
  return false;
};

alignment_specifier
: alignas lparen type_id dot_dot_dot? rparen
| alignas lparen constant_expression dot_dot_dot? rparen
;

attribute_using_prefix
: using attribute_namespace colon
;

attribute_list
: (attribute dot_dot_dot? | attribute?)
    (comma attribute? | attribute dot_dot_dot?)*
;

attribute
: attribute_token attribute_argument_clause?
;

attribute_token
: attribute_scoped_token
| identifier
;

attribute_scoped_token
: attribute_namespace colon_colon identifier
;

attribute_namespace
: identifier
;

attribute_argument_clause
: lparen skip_balanced rparen
;

module_declaration
: export_keyword? module_keyword module_name module_partition? attribute_specifier_seq? semicolon
;

module_name
: module_name_qualifier? identifier
;

module_partition
: colon module_name_qualifier? identifier
;

module_name_qualifier
: identifier dot (identifier dot)*
;

export_declaration
: export declaration
| export lbrace declaration_seq? rbrace
| export_keyword module_import_declaration
;

module_import_declaration
: import_keyword module_name attribute_specifier_seq? semicolon
| import_keyword module_partition attribute_specifier_seq? semicolon
| import_keyword header_name attribute_specifier_seq? semicolon
;

global_module_fragment
: module_keyword semicolon declaration_seq?
;

private_module_fragment
: module_keyword colon private semicolon declaration_seq?
;

class_specifier
: class_head lbrace member_specification? rbrace
;

class_head
: class_key attribute_specifier_seq? class_head_name class_virt_specifier? base_clause?
| class_key attribute_specifier_seq? base_clause?
;

class_head_name
: nested_name_specifier? class_name
;

class_virt_specifier
: final
;

class_key
: class
| struct
| union
;

member_specification
: access_specifier colon member_specification?
| member_declaration member_specification?
;

member_declaration
: __extension__? attribute_specifier_seq? decl_specifier_seq_no_typespecs? declarator_id attribute_specifier_seq? parameters_and_qualifiers semicolon
| __extension__? attribute_specifier_seq? decl_specifier_seq? member_declarator_list? semicolon
| function_definition
| using_declaration
| using_enum_declaration
| static_assert_declaration
| template_declaration
| explicit_specialization
| deduction_guide
| alias_declaration
| opaque_enum_declaration
| empty_declaration
;

member_declarator_list
: member_declarator (comma member_declarator)*
;

member_declarator
: identifier? attribute_specifier_seq? colon constant_expression brace_or_equal_initializer?
| declarator ( requires_clause
             | brace_or_equal_initializer
             | virt_specifier_seq? pure_specifier?)
;

virt_specifier
: override
| final
;

pure_specifier
: equal integer_literal
;

conversion_function_id
: operator conversion_type_id
;

conversion_type_id
: type_specifier_seq conversion_declarator?
;

conversion_declarator
: ptr_operator conversion_declarator?
;

base_clause
: colon base_specifier_list
;

base_specifier_list
: base_specifier dot_dot_dot? (comma base_specifier dot_dot_dot?)*
;

base_specifier
: attribute_specifier_seq? class_or_decltype
| attribute_specifier_seq? virtual access_specifier? class_or_decltype
| attribute_specifier_seq? access_specifier virtual? class_or_decltype
;

class_or_decltype
: nested_name_specifier template simple_template_id
| nested_name_specifier? type_name
| decltype_specifier
;

access_specifier
: private
| protected
| public
;

ctor_initializer
: colon mem_initializer_list
;

mem_initializer_list
: mem_initializer dot_dot_dot? (comma mem_initializer dot_dot_dot?)*
;

mem_initializer
: mem_initializer_id lparen expression_list? rparen
| mem_initializer_id braced_init_list
;

mem_initializer_id
: class_or_decltype
| identifier
;

operator_function_id
: operator op
;

op
: new lbracket rbracket
| delete lbracket rbracket
| new
| delete
| co_await
| lparen rparen
| lbracket rbracket
| minus_greater
| minus_greater_star
| tilde
| exclaim
| plus
| minus
| star
| slash
| percent
| caret
| amp
| bar
| equal
| plus_equal
| minus_equal
| star_equal
| slash_equal
| percent_equal
| caret_equal
| amp_equal
| bar_equal
| equal_equal
| exclaim_equal
| less
| less_equal
| greater_greater_equal
| greater_greater
| greater_equal
| greater
| less_equal_greater
| amp_amp
| bar_bar
| less_less
| less_less_equal
| plus_plus
| minus_minus
| comma
;

literal_operator_id
: operator string_literal identifier
| operator user_defined_string_literal
;

template_declaration
: template_head concept_definition
| template_head declaration
;

template_head
: template less template_parameter_list greater requires_clause?
;

template_parameter_list
: template_parameter (comma template_parameter)*
;

requires_clause
: requires constraint_logical_or_expression
;

constraint_logical_or_expression
: constraint_logical_and_expression (bar_bar constraint_logical_and_expression)*
;

constraint_logical_and_expression
: primary_expression (amp_amp primary_expression)*
;

template_parameter
: type_parameter / (comma | greater)
| parameter_declaration
;

type_parameter
: type_parameter_key identifier? equal type_id
| type_parameter_key dot_dot_dot? identifier?
| type_constraint identifier? equal type_id
| type_constraint dot_dot_dot? identifier?
| template_head type_parameter_key identifier? equal id_expression
| template_head type_parameter_key dot_dot_dot? identifier?
;

type_parameter_key
: class
| typename
;

type_constraint
: nested_name_specifier? concept_name (less template_argument_list? greater)?
;

simple_template_id
: template_name less template_argument_list? greater
;

template_id
: operator_function_id less template_argument_list? greater
| literal_operator_id less template_argument_list? greater
| simple_template_id
;

template_argument_list
{
  TemplArgContext templArgContext(this);
}
: template_argument dot_dot_dot? (comma template_argument dot_dot_dot?)*
;

template_argument
: type_id / (comma | greater | dot_dot_dot)
| template_argument_constant_expression / (comma | greater | dot_dot_dot)
| id_expression
;

constraint_expression
: logical_or_expression(false)
;

deduction_guide
: explicit_specifier? template_name lparen parameter_declaration_clause rparen minus_greater simple_template_id semicolon
;

concept_definition
: concept concept_name equal constraint_expression semicolon
;

concept_name
: identifier
;

typename_specifier
: typename nested_name_specifier template? simple_template_id
| typename nested_name_specifier identifier
;

explicit_instantiation
: extern? template declaration
;

explicit_specialization
: template less greater declaration
;

try_block
: try compound_statement handler_seq
;

function_try_block
: try ctor_initializer? compound_statement handler_seq
;

handler
: catch lparen exception_declaration rparen compound_statement
;

handler_seq: handler+;

exception_declaration
: attribute_specifier_seq? type_specifier_seq declarator
| attribute_specifier_seq? type_specifier_seq abstract_declarator?
| dot_dot_dot?
;

noexcept_specifier
: noexcept lparen constant_expression rparen
| noexcept
| throw lparen rparen // deprecated
;

identifier_list
: identifier (comma identifier)*
;

