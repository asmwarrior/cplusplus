// Copyright (c) 2020 Roberto Raggi <roberto.raggi@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

%class Parser

%token-type TokenKind

%{
  class DeclarativeRegion;

  struct NamespaceData {
    DeclarativeRegion* region = nullptr;
  };

  struct ClassData {
    DeclarativeRegion* region = nullptr;
    DeclarativeRegion* lexicalRegion = nullptr;
    bool isComplete = false;
  };

  class Symbol {
   public:
    Name name;
    Symbol* next = nullptr;
    std::size_t index = 0;
    std::variant<std::monostate, NamespaceData, ClassData> data;

    size_t hashCode() {
      return cxx::hashCode(name);
    }

    bool isNamespace() const {
      return std::holds_alternative<NamespaceData>(data);
    }

    bool isClass() const {
      return std::holds_alternative<ClassData>(data);
    }
  };

  class Scope {
    std::vector<Symbol*> symbols_;
    std::vector<Symbol*> buckets_;

   public:
    auto begin() const { return symbols_.begin(); }

    auto end() const { return symbols_.end(); }

    Symbol* find(const Name& name) const {
      if (symbols_.empty()) return nullptr;
      const auto h = hashCode(name) % buckets_.size();
      for (auto sym = buckets_[h]; sym; sym = sym->next) {
        if (sym->name == name)
          return sym;
      }
      return nullptr;
    }

    void add(Symbol* symbol) {
      symbol->index = symbols_.size();
      symbols_.push_back(symbol);
      if (symbols_.size() < (buckets_.size() * 0.6)) {
        const auto h = symbol->hashCode() % buckets_.size();
        symbol->next = buckets_[h];
        buckets_[h] = symbol;
      } else {
        rehash();
      }
    }

    void rehash() {
      buckets_ = std::vector<Symbol*>(buckets_.empty() ? 8 : buckets_.size() * 2);
      for (auto symbol: symbols_) {
        const auto h = symbol->hashCode() % buckets_.size();
        symbol->next = buckets_[h];
        buckets_[h] = symbol;
      }
    }
  };

  class DeclarativeRegion {
   public:
    DeclarativeRegion* enclosing;
    Scope scope;

    explicit DeclarativeRegion(DeclarativeRegion* enclosing)
      : enclosing(enclosing) {}

    void dump(std::ostream& out, int depth = 0) {
      std::string ind(depth * 2, ' ');
      for (auto sym: scope) {
        if (auto ns = std::get_if<NamespaceData>(&sym->data)) {
          fmt::print("{}- namespace {}\n", ind, toString(sym->name));
          ns->region->dump(out, depth + 1);
        } else if (auto udt = std::get_if<ClassData>(&sym->data)) {
          fmt::print("{}- class {}\n", ind, toString(sym->name));
          udt->region->dump(out, depth + 1);
        }
      }
    }

    struct Context {
      Context(const Context&) = delete;
      Context& operator=(const Context&) = delete;

      Parser* p;
      DeclarativeRegion* savedRegion_;

      explicit Context(Parser* p): p(p), savedRegion_(p->currentRegion_) {}

      ~Context() { p->currentRegion_ = savedRegion_; }

      void enter(DeclarativeRegion* region = nullptr) {
        if (!region)
          region = p->newDeclarativeRegion(savedRegion_);

        p->currentRegion_ = region;
      }

      void leave()
      {
        p->currentRegion_ = savedRegion_;
      }
    };
  };

  DeclarativeRegion* newDeclarativeRegion(DeclarativeRegion* enclosing) {
    return &regions_.emplace_front(DeclarativeRegion(enclosing));
  }

  Symbol* newSymbol() {
    return &symbols_.emplace_front();
  }

  DeclarativeRegion* currentRegion_ = nullptr;
  std::forward_list<DeclarativeRegion> regions_;
  std::forward_list<Symbol> symbols_;

  enum struct Prec {
    kLogicalOr,
    kLogicalAnd,
    kInclusiveOr,
    kExclusiveOr,
    kAnd,
    kEquality,
    kRelational,
    kCompare,
    kShift,
    kAdditive,
    kMultiplicative,
    kPm,
  };

  static Prec prec(TokenKind tk) {
    switch (tk) {
    default:
      std::runtime_error("expected a binary operator");

    case TokenKind::T_DOT_STAR:
    case TokenKind::T_MINUS_GREATER_STAR:
      return Prec::kPm;

    case TokenKind::T_STAR:
    case TokenKind::T_SLASH:
    case TokenKind::T_PERCENT:
      return Prec::kMultiplicative;

    case TokenKind::T_PLUS:
    case TokenKind::T_MINUS:
      return Prec::kAdditive;

    case TokenKind::T_LESS_LESS:
    case TokenKind::T_GREATER_GREATER:
      return Prec::kShift;

    case TokenKind::T_LESS_EQUAL_GREATER:
      return Prec::kCompare;

    case TokenKind::T_LESS_EQUAL:
    case TokenKind::T_GREATER_EQUAL:
    case TokenKind::T_LESS:
    case TokenKind::T_GREATER:
      return Prec::kRelational;

    case TokenKind::T_EQUAL_EQUAL:
    case TokenKind::T_EXCLAIM_EQUAL:
      return Prec::kEquality;

    case TokenKind::T_AMP:
      return Prec::kAnd;

    case TokenKind::T_CARET:
      return Prec::kExclusiveOr;

    case TokenKind::T_BAR:
      return Prec::kInclusiveOr;

    case TokenKind::T_AMP_AMP:
      return Prec::kLogicalAnd;

    case TokenKind::T_BAR_BAR:
      return Prec::kLogicalOr;
    } // switch
  }

  struct DeclaratorId {};
  struct NestedDeclarator {};
  struct PtrDeclarator {};
  struct FunctionDeclarator {};
  struct ArrayDeclarator {};

  using DeclaratorComponent = std::variant<
    DeclaratorId,
    NestedDeclarator,
    PtrDeclarator,
    FunctionDeclarator,
    ArrayDeclarator>;

  using Declarator = std::vector<DeclaratorComponent>;

  bool isFunctionDeclarator(const Declarator& decl) const {
    for (auto d: decl) {
      if (std::holds_alternative<NestedDeclarator>(d))
        continue;
      else if (std::holds_alternative<DeclaratorId>(d))
        continue;
      else if (std::holds_alternative<FunctionDeclarator>(d))
        return true;
      else
        return false;
    }
    return false;
  }

  struct DeclSpecs {
    bool has_simple_typespec = false;
    bool has_complex_typespec = false;
    bool has_named_typespec = false;
    bool has_placeholder_typespec = false;
    bool no_typespecs = false;
    bool no_class_or_enum_specs = false;

    bool accepts_simple_typespec() const {
      return !(has_complex_typespec
        || has_named_typespec
        || has_placeholder_typespec);
    }

    bool has_typespec() const {
      return has_simple_typespec
        || has_complex_typespec
        || has_named_typespec
        || has_placeholder_typespec;
    }
  };

  struct TemplArgContext {
    TemplArgContext(const TemplArgContext&) = delete;
    TemplArgContext& operator=(const TemplArgContext&) = delete;

    Parser* p;

    explicit TemplArgContext(Parser* p): p(p) { ++p->templArgDepth; }
    ~TemplArgContext() { --p->templArgDepth; }
  };

  int templArgDepth = 0;

  template <typename... Args>
  bool parse_warn(const std::string_view& format, const Args&... args)
  {
    unit->report(yycursor, MessageKind::Warning, format, args...);
    return true;
  }

  template <typename... Args>
  bool parse_error(const std::string_view& format, const Args&... args)
  {
    unit->report(yycursor, MessageKind::Error, format, args...);
    return true;
  }

  bool parse_decl_specifier_seq_no_typespecs()
  {
    DeclSpecs specs;
    return parse_decl_specifier_seq_no_typespecs(specs);
  }

  bool parse_decl_specifier_seq()
  {
    DeclSpecs specs;
    return parse_decl_specifier_seq(specs);
  }

  bool parse_declarator()
  {
    Declarator decl;
    return parse_declarator(decl);
  }

  bool yyparse(TranslationUnit* unit, const std::function<void()>& consume);

  const Token& LA(int n = 0) const
  {
    return unit->tokenAt(yycursor + n);
  }

  bool match(TokenKind tk)
  {
    if (yytoken() != tk) return false;
    yyconsume();
    return true;
  }

  bool expect(TokenKind tk)
  {
    if (match(tk)) return true;
    parse_error("expected '{}'", Token::spell(tk));
    return false;
  }

  TranslationUnit* unit = nullptr;
  Arena* pool = nullptr;
  Control* control = nullptr;
  bool skip_function_body = false;
  std::unordered_map<uint32_t, std::tuple<uint32_t, bool>> class_specifiers_;
  std::unordered_map<uint32_t, std::tuple<uint32_t, bool>> template_arguments_;
  std::unordered_map<uint32_t, std::tuple<uint32_t, bool, DeclarativeRegion*>> nested_name_specifiers_;
  bool module_unit = false;
  const Identifier* module_id = nullptr;
  const Identifier* import_id = nullptr;
  const Identifier* final_id = nullptr;
  const Identifier* override_id = nullptr;
  DeclarativeRegion* globalRegion = nullptr;
%}

%token
  eof_symbol
, error
, identifier
, character_literal
, floating_point_literal
, integer_literal
, string_literal
, user_defined_literal
, user_defined_string_literal

// operators and punctuators

, exclaim
, exclaim_equal
, percent
, percent_equal
, amp
, amp_amp
, amp_equal
, lparen
, rparen
, star
, star_equal
, plus
, plus_plus
, plus_equal
, comma
, minus
, minus_minus
, minus_equal
, minus_greater
, minus_greater_star
, dot
, dot_star
, dot_dot_dot
, slash
, slash_equal
, colon
, colon_colon
, semicolon
, less
, less_less
, less_less_equal
, less_equal
, less_equal_greater
, equal
, equal_equal
, greater
, question
, lbracket
, rbracket
, caret
, caret_equal
, lbrace
, bar
, bar_equal
, bar_bar
, rbrace
, tilde

// keywords

, __alignof
, __asm
, __asm__
, __attribute
, __attribute__
, __complex__
, __decltype
, __decltype__
, __extension__
, __float128
, __float80
, __has_unique_object_representations
, __has_virtual_destructor
, __imag__
, __inline
, __inline__
, __int128
, __int64
, __is_abstract
, __is_aggregate
, __is_base_of
, __is_class
, __is_constructible
, __is_convertible_to
, __is_empty
, __is_enum
, __is_final
, __is_function
, __is_literal
, __is_nothrow_assignable
, __is_nothrow_constructible
, __is_pod
, __is_polymorphic
, __is_same
, __is_standard_layout
, __is_trivial
, __is_trivially_assignable
, __is_trivially_constructible
, __is_trivially_copyable
, __is_trivially_destructible
, __is_union
, __real__
, __reference_binds_to_temporary
, __restrict
, __restrict__
, __thread
, __typeof
, __typeof__
, __underlying_type

, _Atomic

, alignas
, alignof
, asm
, auto
, bool
, break
, case
, catch
, char
, char16_t
, char32_t
, char8_t
, class
, co_await
, co_return
, co_yield
, concept
, const
, const_cast
, consteval
, constexpr
, constinit
, continue
, decltype
, default
, delete
, do
, double
, dynamic_cast
, else
, enum
, explicit
, export
, extern
, false
, float
, for
, friend
, goto
, if
, inline
, int
, long
, mutable
, namespace
, new
, noexcept
, nullptr
, operator
, private
, protected
, public
, reinterpret_cast
, requires
, return
, short
, signed
, sizeof
, static
, static_assert
, static_cast
, struct
, switch
, template
, this
, thread_local
, throw
, true
, try
, typedef
, typeid
, typename
, union
, unsigned
, using
, virtual
, void
, volatile
, wchar_t
, while

// module
, import
, module

%extern warn
%extern error

id(const Identifier* id): identifier
{
  return unit->identifier(yycursor - 1) == id;
};

nospace:
{
  const auto& tk = unit->tokenAt(yycursor);
  return !tk.leadingSpace() && !tk.startOfLine();
};

greater_greater
: greater_greater_equal { return false; }
| greater nospace greater;

greater_greater_equal: greater nospace greater nospace equal;

greater_equal: greater nospace equal;

header_name: { return false; };

export_keyword
: { return module_unit; }
  export
;

import_keyword
: import
| { return module_unit; }
  id(import_id)
  { unit->setTokenKind(yycursor - 1, TokenKind::T_MODULE); }
;

module_keyword
: module
| { return unit; }
  id(module_id)
  { unit->setTokenKind(yycursor - 1, TokenKind::T_MODULE); }
;

final: id(final_id);

override: id(override_id);

typedef_name
: simple_template_id
| identifier
;

namespace_name
: identifier
| namespace_alias
;

namespace_alias
: identifier
;

class_name
{
  Name name;
}
: class_name(name)
;

class_name(Name& name)
: simple_template_id(name)
| name_id(name)
;

name_id(Name& name)
: identifier
  { name = unit->identifier(yycursor - 1); }
;

enum_name
: identifier
;

template_name
{
  Name name;
}
: template_name(name)
;

template_name(Name& name)
: name_id(name)
;

literal: {
  switch (yytoken()) {
  case TokenKind::T_TRUE:
  case TokenKind::T_FALSE:
  case TokenKind::T_NULLPTR:
  case TokenKind::T_INTEGER_LITERAL:
  case TokenKind::T_CHARACTER_LITERAL:
  case TokenKind::T_FLOATING_POINT_LITERAL:
  case TokenKind::T_USER_DEFINED_LITERAL:
    yyconsume();
    return true;
  case TokenKind::T_STRING_LITERAL:
    while (match(TokenKind::T_STRING_LITERAL)) {

    }
    return true;
  default:
    return false;
  } // switch
}
;

translation_unit(UnitAST*& yyast)
: eof_symbol
| module_unit(yyast)
| top_level_declaration_seq(yyast)
    // { globalRegion->dump(std::cout); }
;

enter(DeclarativeRegion::Context& context)
: { context.enter(); }
;

leave(DeclarativeRegion::Context& context)
: { context.leave(); }
;

module_unit(UnitAST*& yyast)
{
  DeclarativeRegion::Context region(this);

  globalRegion = newDeclarativeRegion(nullptr);

  region.enter(globalRegion);

  module_unit = true;
}
: global_module_fragment? module_declaration declaration_seq? private_module_fragment? eof
;

eof
: eof_symbol
| error("expected eof")
;

top_level_declaration_seq(UnitAST*& yyast): {
  DeclarativeRegion::Context region(this);

  globalRegion = newDeclarativeRegion(nullptr);

  region.enter(globalRegion);

  bool skipping = false;

  module_unit = false;

  DeclarationAST* d1 = nullptr;

  while (yytoken() != TokenKind::T_EOF_SYMBOL) {
    auto saved = yycursor;
    DeclarationAST* declaration = nullptr;
    if (parse_declaration(declaration)) {
      skipping = false;
    } else {
      parse_skip_top_level_declaration(skipping);
      if (yycursor == saved)
        yyconsume();
    }
  }
};

skip_top_level_declaration(bool& skipping): {
  if (yytoken() == TokenKind::T_EOF_SYMBOL) return false;
  if (!skipping) unit->report(yycursor, MessageKind::Error, "expected a declaration");
  skipping = true;
};

declaration_seq: {
  bool skipping = false;
  while (yytoken() != TokenKind::T_EOF_SYMBOL) {
    if (yytoken() == TokenKind::T_RBRACE) break;
    auto saved = yycursor;
    DeclarationAST* decl = nullptr;
    if (parse_declaration(decl)) {
      skipping = false;
    } else {
      parse_skip_declaration(skipping);
      if (yycursor == saved)
        yyconsume();
    }
  }
};

skip_declaration(bool& skipping): {
  if (yytoken() == TokenKind::T_RBRACE) return false;
  if (yytoken() == TokenKind::T_MODULE) return false;
  if (module_unit && yytoken() == TokenKind::T_EXPORT) return false;
  if (yytoken() == TokenKind::T_IMPORT) return false;
  if (!skipping) unit->report(yycursor, MessageKind::Error, "expected a declaration");
  skipping = true;
};

primary_expression(ExpressionAST*& yyast): {
  if (match(TokenKind::T_THIS))
    return true;
  else if (parse_literal())
    return true;
  else if (yytoken() == TokenKind::T_LBRACKET)
    return parse_lambda_expression(yyast);
  else if (yytoken() == TokenKind::T_REQUIRES)
    return parse_requires_expression(yyast);
  else if (yytoken() == TokenKind::T_LPAREN) {
    auto saved = yycursor;
    yyconsume();
    ExpressionAST* expression = nullptr;
    if (parse_expression(expression)) {
      if (match(TokenKind::T_RPAREN))
        return true;
    }
    yyrewind(saved);
    return parse_fold_expression(yyast);
  }
  return parse_id_expression();
};

id_expression: {
  const auto start = yycursor;
  if (parse_qualified_id())
    return true;
  yyrewind(start);
  return parse_unqualified_id();
};

maybe_template_id: {
  const auto start = yycursor;
  const auto blockErrors = unit->blockErrors(true);
  auto template_id = parse_template_id();
  const auto tk = yytoken();
  unit->blockErrors(blockErrors);
  if (!template_id) return false;
  switch (tk) {
    default: return false;
    case TokenKind::T_COMMA:
    case TokenKind::T_GREATER:
    case TokenKind::T_LPAREN:
    case TokenKind::T_RPAREN:
    case TokenKind::T_STAR:
    case TokenKind::T_AMP:
    case TokenKind::T_AMP_AMP:
    case TokenKind::T_BAR_BAR:
    case TokenKind::T_COLON_COLON:
    case TokenKind::T_DOT_DOT_DOT:
    case TokenKind::T_QUESTION:
    case TokenKind::T_LBRACE:
    case TokenKind::T_RBRACE:
    case TokenKind::T_SEMICOLON:
      return true;
  } // switch
};

unqualified_id: {
  const auto start = yycursor;

  if (parse_maybe_template_id())
      return true;

  yyrewind(start);

  if (match(TokenKind::T_TILDE)) {
    if (parse_decltype_specifier())
      return true;
    return parse_type_name();
  }

  if (yytoken() == TokenKind::T_OPERATOR) {
    if (parse_operator_function_id())
      return true;
    yyrewind(start);
    if (parse_conversion_function_id())
      return true;
    yyrewind(start);
    return parse_literal_operator_id();
  }

  if (!match(TokenKind::T_IDENTIFIER))
    return false;
  return true;
};

qualified_id: {
  if (!parse_nested_name_specifier())
    return false;
  const auto has_template = match(TokenKind::T_TEMPLATE);
  if (parse_unqualified_id())
    return true;
  if (has_template) {
    parse_error("expected a template name");
    return true;
  }
  return false;
};

nested_name_specifier: {
  DeclarativeRegion* region = nullptr;
  return parse_nested_name_specifier(region);
};

nested_name_specifier(DeclarativeRegion*& region)
{
  const auto start = yycursor;
  auto it = nested_name_specifiers_.find(start);
  if (it != nested_name_specifiers_.end()) {
    auto [cursor, parsed, result] = it->second;
    yyrewind(cursor);
    region = result;
    return parsed;
  }
  struct Context {
    Parser* p;
    uint32_t start;
    bool parsed = false;
    DeclarativeRegion* region = nullptr;
    Context(Parser *p): p(p), start(p->yycursor) {}
    ~Context() {
      p->nested_name_specifiers_.emplace(start, std::make_tuple(p->yycursor, parsed, region));
    }
  } context(this);
  Symbol* sym = nullptr;
  region = currentRegion_;
  Name id;
}
: ( colon_colon
  | name_id(id) colon_colon
  | simple_template_id(id) colon_colon
  | decltype_specifier colon_colon)
      ( name_id(id) colon_colon
      | template? simple_template_id(id) colon_colon
      )*
    {
      context.parsed = true;
      context.region = region;
    }
;

lambda_expression(ExpressionAST*& yyast): {
  if (!parse_lambda_introducer())
    return false;

  DeclarativeRegion::Context region(this);

  if (match(TokenKind::T_LESS)) {
    parse_enter(region);
    if (!parse_template_parameter_list())
      parse_error("expected a template paramter");
    expect(TokenKind::T_GREATER);
    parse_requires_clause();
  }

  if (yytoken() != TokenKind::T_LBRACE) {
    if (!parse_lambda_declarator())
      parse_error("expected lambda declarator");
  }

  StatementAST* statement = nullptr;
  if (!parse_compound_statement(statement))
    parse_error("expected a compound statement");
};

lambda_introducer: {
  if (!match(TokenKind::T_LBRACKET))
    return false;
  if (!match(TokenKind::T_RBRACKET)) {
    if (!parse_lambda_capture())
      parse_error("expected a lambda capture");
    expect(TokenKind::T_RBRACKET);
  }
};

lambda_declarator: {
  if (!match(TokenKind::T_LPAREN))
    return false;
  if (!match(TokenKind::T_RPAREN)) {
    if (!parse_parameter_declaration_clause())
      parse_error("expected a parameter declaration clause");
    expect(TokenKind::T_RPAREN);
  }
  parse_decl_specifier_seq();
  parse_noexcept_specifier();
  parse_attribute_specifier_seq();
  parse_trailing_return_type();
  parse_requires_clause();
};

lambda_capture
: capture_list
| capture_default (comma capture_list)?
;

capture_default
: amp
| equal
;

capture_list
: capture (comma capture)*
;

capture
: init_capture
| simple_capture
;

simple_capture
: identifier dot_dot_dot?
| amp identifier dot_dot_dot?
| this
| star this
;

init_capture
: dot_dot_dot? identifier initializer
| amp dot_dot_dot? identifier initializer
;

fold_expression(ExpressionAST*& yyast)
{
  ExpressionAST* e1 = nullptr;
  ExpressionAST* e2 = nullptr;
}
: lparen cast_expression(e1) fold_operator dot_dot_dot (fold_operator cast_expression(e2))? rparen
| lparen dot_dot_dot fold_operator cast_expression(e1) rparen
;

fold_operator
: plus
| minus
| star
| slash
| percent
| caret
| amp
| bar
| less_less
| plus_equal
| minus_equal
| star_equal
| slash_equal
| percent_equal
| caret_equal
| amp_equal
| bar_equal
| less_less_equal
| greater_greater_equal
| greater_greater
| greater_equal
| greater
| equal
| equal_equal
| exclaim_equal
| less
| less_equal
| amp_amp
| bar_bar
| comma
| dot_star
| minus_greater_star
;

requires_expression(ExpressionAST*& yyast)
: requires requirement_parameter_list? requirement_body
;

requirement_parameter_list
: lparen parameter_declaration_clause? rparen
;

requirement_body
: lbrace requirement_seq rbrace
;

requirement_seq
: requirement+;

requirement
: simple_requirement
| type_requirement
| compound_requirement
| nested_requirement
;

simple_requirement
{
  ExpressionAST* e1 = nullptr;
}
: expression(e1) semicolon
;

type_requirement
: typename nested_name_specifier? type_name semicolon
;

compound_requirement
{
  ExpressionAST* e1 = nullptr;
}
: lbrace expression(e1) rbrace noexcept? return_type_requirement? semicolon
;

return_type_requirement
: minus_greater type_constraint
;

nested_requirement
{
  ExpressionAST* e1 = nullptr;
}
: requires constraint_expression(e1) semicolon
;

postfix_expression(ExpressionAST*& yyast)
{
  DeclSpecs specs;
  ExpressionAST* e1 = nullptr;
}
: ( const_cast less type_id greater lparen expression(e1) rparen
  | dynamic_cast less type_id greater lparen expression(e1) rparen
  | reinterpret_cast less type_id greater lparen expression(e1) rparen
  | simple_type_specifier(specs) ( braced_init_list
                                 | lparen expression_list? rparen)
  | static_cast less type_id greater lparen expression(e1) rparen
  | typeid lparen expression(e1) rparen
  | typeid lparen type_id rparen
  | typename_specifier braced_init_list
  | typename_specifier lparen expression_list? rparen
  | __has_unique_object_representations lparen type_id rparen
  | __has_virtual_destructor lparen type_id rparen
  | __is_abstract lparen type_id rparen
  | __is_aggregate lparen type_id rparen
  | __is_base_of lparen type_id comma type_id rparen
  | __is_class lparen type_id rparen
  | __is_constructible lparen type_id comma type_id rparen
  | __is_convertible_to lparen type_id comma type_id rparen
  | __is_empty lparen type_id rparen
  | __is_enum lparen type_id rparen
  | __is_final lparen type_id rparen
  | __is_function lparen type_id rparen
  | __is_nothrow_assignable lparen type_id comma type_id rparen
  | __is_nothrow_constructible lparen type_id comma type_id rparen
  | __is_pod lparen type_id rparen
  | __is_polymorphic lparen type_id rparen
  | __is_same lparen type_id comma type_id rparen
  | __is_standard_layout lparen type_id rparen
  | __is_trivial lparen type_id rparen
  | __is_trivially_assignable lparen type_id comma type_id rparen
  | __is_trivially_constructible lparen type_id comma type_id rparen
  | __is_trivially_copyable lparen type_id rparen
  | __is_trivially_destructible lparen type_id rparen
  | __is_union lparen type_id rparen
  | __reference_binds_to_temporary lparen type_id comma type_id rparen
  | primary_expression(yyast))
    ( dot template? id_expression
    | lbracket expr_or_braced_init_list rbracket
    | lparen expression_list? rparen
    | minus_greater template? id_expression
    | minus_minus
    | plus_plus)*
;

expression_list: {
  return parse_initializer_list();
};

unary_expression(ExpressionAST*& yyast)
: unop_expression(yyast)
| complex_expression(yyast)
| await_expression(yyast)
| sizeof_expression(yyast)
| alignof_expression(yyast)
| noexcept_expression(yyast)
| new_expression(yyast)
| delete_expression(yyast)
| postfix_expression(yyast)
;

unop_expression(ExpressionAST*& yyast): {
  if (!parse_unary_operator() && !match(TokenKind::T_PLUS_PLUS) && !match(TokenKind::T_MINUS_MINUS))
    return false;
  ExpressionAST* expression = nullptr;
  if (!parse_cast_expression(expression))
    parse_error("expected an expression");
};

complex_expression(ExpressionAST*& yyast): {
  if (!match(TokenKind::T___IMAG__) && !match(TokenKind::T___REAL__))
    return false;
  ExpressionAST* expression = nullptr;
  if (!parse_cast_expression(expression))
    parse_error("expected an expression");
};

sizeof_expression(ExpressionAST*& yyast): {
  if (!match(TokenKind::T_SIZEOF))
    return false;

  if (match(TokenKind::T_DOT_DOT_DOT)) {
    expect(TokenKind::T_LPAREN);
    expect(TokenKind::T_IDENTIFIER);
    expect(TokenKind::T_RPAREN);
    return true;
  }

  const auto after_sizeof_op = yycursor;

  if (match(TokenKind::T_LPAREN)) {
    if (parse_type_id() && match(TokenKind::T_RPAREN)) {
      return true;
    }
    yyrewind(after_sizeof_op);
  }

  ExpressionAST* expression = nullptr;
  if (!parse_unary_expression(expression))
    parse_error("expected an expression");
};

alignof_expression(ExpressionAST*& yyast): {
  if (!match(TokenKind::T_ALIGNOF) && !match(TokenKind::T___ALIGNOF))
    return false;
  expect(TokenKind::T_LPAREN);
  if (!parse_type_id())
    parse_error("expected a type id");
  expect(TokenKind::T_RPAREN);
};

unary_operator: {
  switch (yytoken()) {
  default: return false;
  case TokenKind::T_STAR:
  case TokenKind::T_AMP:
  case TokenKind::T_PLUS:
  case TokenKind::T_MINUS:
  case TokenKind::T_EXCLAIM:
  case TokenKind::T_TILDE:
    yyconsume();
    return true;
  } // switch
};

await_expression(ExpressionAST*& yyast): {
  if (!match(TokenKind::T_CO_AWAIT))
    return false;
  expect(TokenKind::T_LPAREN);
  ExpressionAST* expression = nullptr;
  if (!parse_cast_expression(expression))
    parse_error("expected an expression");
  expect(TokenKind::T_RPAREN);
};

noexcept_expression(ExpressionAST*& yyast): {
  if (!match(TokenKind::T_NOEXCEPT))
    return false;
  expect(TokenKind::T_LPAREN);
  ExpressionAST* expression = nullptr;
  if (!parse_expression(expression))
    parse_error("expected an expression");
  expect(TokenKind::T_RPAREN);
};

new_expression(ExpressionAST*& yyast)
: colon_colon? new new_placement? new_type_id new_initializer?
| colon_colon? new new_placement? lparen type_id rparen new_initializer?
;

new_placement
: lparen expression_list rparen
;

new_type_id
: type_specifier_seq new_declarator?
;

new_declarator
: ptr_operator new_declarator?
| noptr_new_declarator
;

noptr_new_declarator
{
  ExpressionAST* e1 = nullptr;
  ExpressionAST* e2 = nullptr;
}
: lbracket expression(e1)? rbracket attribute_specifier_seq? (lbracket constant_expression(e2) rbracket attribute_specifier_seq?)*
;

new_initializer
: lparen expression_list? rparen
| braced_init_list
;

delete_expression(ExpressionAST*& yyast)
{
  ExpressionAST* e1 = nullptr;
}
: colon_colon? delete (lbracket rbracket)? cast_expression(e1)
;

cast_expression(ExpressionAST*& yyast)
{
  ExpressionAST* e1 = nullptr;
}
: lparen type_id rparen cast_expression(e1)
| unary_expression(yyast)
;

binary_operator(TokenKind& tk, bool templArg)
: greater_equal
| greater_greater
    {
      if (templArg && templArgDepth >= 2)
        return false;
      tk = TokenKind::T_GREATER_GREATER;
    }
| ( star
  | slash
  | plus
  | percent
  | minus_greater_star
  | minus
  | less_less
  | less_equal_greater
  | less_equal
  | less
  | { return !templArg; } greater
  | exclaim_equal
  | equal_equal
  | dot_star
  | caret
  | bar_bar
  | bar
  | amp_amp
  | amp ) { tk = unit->tokenKind(yycursor - 1); }
;

binary_expression(ExpressionAST*& yyast, bool templArg)
: cast_expression(yyast) binary_expression_helper(yyast, Prec::kLogicalOr, templArg)?
;

binary_expression_helper(ExpressionAST*& yyast, Prec minPrec, bool templArg)
{
  TokenKind op = TokenKind::T_EOF_SYMBOL;
  TokenKind nextOp = TokenKind::T_EOF_SYMBOL;
  ExpressionAST* rhs = nullptr;
}
: (binary_operator(op, templArg) { return prec(op) >= minPrec; }
    cast_expression(rhs)
    ({} / (binary_operator(nextOp, templArg) { return prec(nextOp) > prec(op); })
      binary_expression_helper(rhs, prec(op), templArg)
    )*
  )+
;

logical_or_expression(ExpressionAST*& yyast, bool templArg)
: binary_expression(yyast, templArg)
;

conditional_expression(ExpressionAST*& yyast, bool templArg): {
  if (!parse_logical_or_expression(yyast, templArg))
    return false;
  if (match(TokenKind::T_QUESTION)) {
    ExpressionAST* iftrue_expression = nullptr;
    if (!parse_expression(iftrue_expression))
      parse_error("expected an expression");
    expect(TokenKind::T_COLON);
    ExpressionAST* iffalse_expression = nullptr;
    if (templArg) {
      if (!parse_conditional_expression(iffalse_expression, templArg)) {
        parse_error("expected an expression");
      }
    } else if (!parse_assignment_expression(iffalse_expression)) {
      parse_error("expected an expression");
    }
  }
};

yield_expression(ExpressionAST*& yyast): {
  if (!match(TokenKind::T_CO_YIELD))
    return false;
  if (yytoken() == TokenKind::T_LBRACE) {
    if (!parse_braced_init_list())
      parse_error("expected a braced initializer");
  } else {
    ExpressionAST* expression = nullptr;
    if (!parse_assignment_expression(expression))
      parse_error("expected an expression");
  }
};

throw_expression(ExpressionAST*& yyast): {
  if (!match(TokenKind::T_THROW))
    return false;
  ExpressionAST* expression = nullptr;
  const auto saved = yycursor;
  if (!parse_assignment_expression(expression))
    yyrewind(saved);
};

assignment_expression(ExpressionAST*& yyast): {
  if (parse_yield_expression(yyast))
    return true;
  if (parse_throw_expression(yyast))
    return true;
  if (!parse_conditional_expression(yyast, false))
    return false;
  if (parse_assignment_operator()) {
    ExpressionAST* expression = nullptr;
    if (!parse_initializer_clause(expression))
      parse_error("expected an expression");
  }
};

assignment_operator
: equal
| star_equal
| slash_equal
| percent_equal
| plus_equal
| minus_equal
| greater_greater_equal
| less_less_equal
| amp_equal
| caret_equal
| bar_equal
;

expression(ExpressionAST*& yyast): {
  if (!parse_assignment_expression(yyast))
    return false;
  while (match(TokenKind::T_COMMA)) {
    ExpressionAST* expression = nullptr;
    if (!parse_assignment_expression(expression))
      parse_error("expected an expression");
  }
};

constant_expression(ExpressionAST*& yyast)
: conditional_expression(yyast, false)
;

template_argument_constant_expression(ExpressionAST*& yyast)
: conditional_expression(yyast, true)
;

statement(StatementAST*& yyast): {
  bool has_extension = false;

  if (match(TokenKind::T___EXTENSION__)) {
    has_extension = false;
  }

  bool has_attribute_specifiers = false;

  if (parse_attribute_specifier_seq()) {
    has_attribute_specifiers = true;
  }

  const auto start = yycursor;

  switch (yytoken()) {
    case TokenKind::T_CASE:
      return parse_case_statement(yyast);
    case TokenKind::T_DEFAULT:
      return parse_default_statement(yyast);
    case TokenKind::T_WHILE:
      return parse_while_statement(yyast);
    case TokenKind::T_DO:
      return parse_do_statement(yyast);
    case TokenKind::T_FOR:
      if (parse_for_range_statement(yyast))
        return true;
      yyrewind(start);
      return parse_for_statement(yyast);
    case TokenKind::T_IF:
      return parse_if_statement(yyast);
    case TokenKind::T_SWITCH:
      return parse_switch_statement(yyast);
    case TokenKind::T_BREAK:
      return parse_break_statement(yyast);
    case TokenKind::T_CONTINUE:
      return parse_continue_statement(yyast);
    case TokenKind::T_RETURN:
      return parse_return_statement(yyast);
    case TokenKind::T_GOTO:
      return parse_goto_statement(yyast);
    case TokenKind::T_CO_RETURN:
      return parse_coroutine_return_statement(yyast);
    case TokenKind::T_TRY:
      return parse_try_block(yyast);
    case TokenKind::T_LBRACE:
      return parse_compound_statement(yyast);
    default:
      if (yytoken() == TokenKind::T_IDENTIFIER && yytoken(1) == TokenKind::T_COLON) {
        return parse_labeled_statement(yyast);
      } else if (parse_declaration_statement(yyast)) {
        return true;
      }
      yyrewind(start);
      return parse_expression_statement(yyast);
  } // switch
};

init_statement(StatementAST*& yyast): {
  if (yytoken() == TokenKind::T_RPAREN)
    return false;
  auto saved = yycursor;
  DeclarationAST* declaration = nullptr;
  if (parse_simple_declaration(declaration, false))
    return true;
  yyrewind(saved);
  ExpressionAST* expression = nullptr;
  if (!parse_expression(expression))
    return false;
  if (!match(TokenKind::T_SEMICOLON))
    return false;
};

condition(ExpressionAST*& yyast): {
  const auto start = yycursor;
  parse_attribute_specifier_seq();
  if (parse_decl_specifier_seq()) {
    if (parse_declarator()) {
      if (parse_brace_or_equal_initializer())
        return true;
    }
  }
  yyrewind(start);
  return parse_expression(yyast);
};

labeled_statement(StatementAST*& yyast): {
  if (!match(TokenKind::T_IDENTIFIER))
    return false;
  expect(TokenKind::T_COLON);
  StatementAST* statement = nullptr;
  if (!parse_statement(statement))
    parse_error("expected a statement");
};

case_statement(StatementAST*& yyast): {
  if (!match(TokenKind::T_CASE))
    return false;
  ExpressionAST* expression = nullptr;
  if (!parse_constant_expression(expression))
    parse_error("expected an expression");
  expect(TokenKind::T_COLON);
  StatementAST* statement = nullptr;
  if (!parse_statement(statement))
    parse_error("expected a statement");
};

default_statement(StatementAST*& yyast): {
  if (!match(TokenKind::T_DEFAULT))
    return false;
  expect(TokenKind::T_COLON);
  StatementAST* statement = nullptr;
  if (!parse_statement(statement))
    parse_error("expected a statement");
};

expression_statement(StatementAST*& yyast): {
  if (!match(TokenKind::T_SEMICOLON)) {
    ExpressionAST* expression = nullptr;
    if (!parse_expression(expression))
      return false;
    expect(TokenKind::T_SEMICOLON);
  }
};

compound_statement(StatementAST*& yyast): {
  DeclarativeRegion::Context region(this);
  bool skipping = false;
  if (!match(TokenKind::T_LBRACE)) return false;
  parse_enter(region);
  while (auto tk = LA()) {
    if (yytoken() == TokenKind::T_RBRACE)
      break;
    StatementAST* s = nullptr;
    if (parse_statement(s)) {
      skipping = false;
    } else {
      parse_skip_statement(skipping);
    }
  }
  if (!expect(TokenKind::T_RBRACE)) return false;
  return true;
};

skip_statement(bool& skipping): {
  if (yytoken() == TokenKind::T_EOF_SYMBOL) return false;
  if (yytoken() == TokenKind::T_RBRACE) return false;
  if (!skipping) unit->report(yycursor, MessageKind::Error, "expected a statement");
  for (; yytoken() != TokenKind::T_EOF_SYMBOL; yyconsume()) {
    if (yytoken() == TokenKind::T_SEMICOLON) break;
    if (yytoken() == TokenKind::T_LBRACE) break;
    if (yytoken() == TokenKind::T_RBRACE) break;
  }
  skipping = true;
};

if_statement(StatementAST*& yyast): {
  if (!match(TokenKind::T_IF)) return false;
  bool has_constexpr = match(TokenKind::T_CONSTEXPR);
  expect(TokenKind::T_LPAREN);
  auto start = yycursor;
  StatementAST* initializer = nullptr;
  if (!parse_init_statement(initializer))
    yyrewind(start);
  ExpressionAST* condition = nullptr;
  parse_condition(condition);
  expect(TokenKind::T_RPAREN);
  StatementAST* statement = nullptr;
  if (!parse_statement(statement))
    parse_error("expected a statement");
  if (match(TokenKind::T_ELSE)) {
    StatementAST* else_statement = nullptr;
    if (!parse_statement(else_statement))
      parse_error("expected a statement");
  }
};

switch_statement(StatementAST*& yyast): {
  if (!match(TokenKind::T_SWITCH))
    return false;
  expect(TokenKind::T_LPAREN);
  StatementAST* initializer = nullptr;
  auto start = yycursor;
  if (!parse_init_statement(initializer))
    yyrewind(start);
  ExpressionAST* condition = nullptr;
  parse_condition(condition);
  expect(TokenKind::T_RPAREN);
  StatementAST* statement = nullptr;
  parse_statement(statement);
};

while_statement(StatementAST*& yyast): {
  if (!match(TokenKind::T_WHILE))
    return false;
  expect(TokenKind::T_LPAREN);
  ExpressionAST* condition = nullptr;
  if (!parse_condition(condition))
    parse_error("expected a condition");
  expect(TokenKind::T_RPAREN);
  StatementAST* statement = nullptr;
  if (!parse_statement(statement))
    parse_error("expected a statement");
};

do_statement(StatementAST*& yyast): {
  if (!match(TokenKind::T_DO))
    return false;
  StatementAST* statement = nullptr;
  if (!parse_statement(statement))
    parse_error("expected a statement");
  expect(TokenKind::T_WHILE);
  expect(TokenKind::T_LPAREN);
  ExpressionAST* expression = nullptr;
  if (!parse_expression(expression))
    parse_error("expected an expression");
  expect(TokenKind::T_RPAREN);
};

for_range_statement(StatementAST*& yyast): {
  if (!match(TokenKind::T_FOR))
    return false;
  if (!match(TokenKind::T_LPAREN))
    return false;
  auto saved = yycursor;
  StatementAST* initializer = nullptr;
  if (!parse_init_statement(initializer))
    yyrewind(saved);
  if (!parse_for_range_declaration())
    return false;
  if (!match(TokenKind::T_COLON))
    return false;
  if (!parse_for_range_initializer())
    parse_error("expected for-range intializer");
  expect(TokenKind::T_RPAREN);
  StatementAST* statement = nullptr;
  if (!parse_statement(statement))
    parse_error("expected a statement");
};

for_statement(StatementAST*& yyast): {
  StatementAST* s1 = nullptr;
  StatementAST* s2 = nullptr;
  ExpressionAST* e1 = nullptr;
  ExpressionAST* e2 = nullptr;
  if (!match(TokenKind::T_FOR))
    return false;
  expect(TokenKind::T_LPAREN);
  if (!parse_init_statement(s1))
    parse_error("expected a statement");
  if (!match(TokenKind::T_SEMICOLON)) {
    if (!parse_condition(e1))
      parse_error("expected a condition");
    expect(TokenKind::T_SEMICOLON);
  }
  if (!match(TokenKind::T_RPAREN)) {
    if (!parse_expression(e2))
      parse_error("expected an expression");
    expect(TokenKind::T_RPAREN);
  }
  if (!parse_statement(s2))
    parse_error("expected a statement");
};

for_range_declaration: {
  parse_attribute_specifier_seq();
  if (!parse_decl_specifier_seq())
    return false;
  auto tk = yytoken();
  if (tk == TokenKind::T_AMP || tk == TokenKind::T_AMP_AMP || tk == TokenKind::T_LBRACKET) {
    parse_ref_qualifier();
    expect(TokenKind::T_LBRACKET);
    if (!parse_identifier_list())
      parse_error("expected an identifier");
    expect(TokenKind::T_RBRACKET);
  } else {
    return parse_declarator();
  }
};

for_range_initializer
: expr_or_braced_init_list
;

break_statement(StatementAST*& yyast): {
  if (!match(TokenKind::T_BREAK))
    return false;
  expect(TokenKind::T_SEMICOLON);
};

continue_statement(StatementAST*& yyast): {
  if (!match(TokenKind::T_CONTINUE))
    return false;
  expect(TokenKind::T_SEMICOLON);
};

return_statement(StatementAST*& yyast): {
  if (!match(TokenKind::T_RETURN))
    return false;
  if (!match(TokenKind::T_SEMICOLON)) {
    if (!parse_expr_or_braced_init_list())
      parse_error("expected an expression or ';'");
    expect(TokenKind::T_SEMICOLON);
  }
};

goto_statement(StatementAST*& yyast): {
  if (!match(TokenKind::T_GOTO))
    return false;
  expect(TokenKind::T_IDENTIFIER);
  expect(TokenKind::T_SEMICOLON);
};

coroutine_return_statement(StatementAST*& yyast): {
  if (!match(TokenKind::T_CO_RETURN))
    return false;
  if (!match(TokenKind::T_SEMICOLON)) {
    if (!parse_expr_or_braced_init_list())
      parse_error("expected an expression");
    expect(TokenKind::T_SEMICOLON);
  }
};

declaration_statement(StatementAST*& yyast): {
  DeclarationAST* declaration = nullptr;
  if (!parse_block_declaration(declaration, false))
    return false;
};

declaration(DeclarationAST*& yyast): {
  if (yytoken() == TokenKind::T_RBRACE)
    return false;
  else if (parse_module_keyword())
    return false;

  auto start = yycursor;

  if (yytoken() == TokenKind::T_SEMICOLON)
    return parse_empty_declaration(yyast);

  yyrewind(start);
  if (parse_explicit_instantiation(yyast))
    return true;

  yyrewind(start);
  if (parse_explicit_specialization(yyast))
    return true;

  yyrewind(start);
  if (parse_template_declaration(yyast))
    return true;

  yyrewind(start);
  if (parse_deduction_guide(yyast))
    return true;

  yyrewind(start);
  if (parse_export_declaration(yyast))
    return true;

  yyrewind(start);
  if (parse_linkage_specification(yyast))
    return true;

  yyrewind(start);
  if (parse_namespace_definition(yyast))
    return true;

  yyrewind(start);
  if (parse_attribute_declaration(yyast))
    return true;

  yyrewind(start);
  if (parse_module_import_declaration(yyast))
    return true;

  yyrewind(start);
  return parse_block_declaration(yyast, true);
};

block_declaration(DeclarationAST*& yyast, bool fundef): {
  const auto start = yycursor;

  const auto tk = yytoken();

  if (parse_asm_declaration(yyast))
    return true;

  yyrewind(start);
  if (parse_namespace_alias_definition(yyast))
    return true;

  yyrewind(start);
  if (parse_using_directive(yyast))
    return true;

  yyrewind(start);
  if (parse_alias_declaration(yyast))
    return true;

  yyrewind(start);
  if (parse_using_declaration(yyast))
    return true;

  yyrewind(start);
  if (parse_using_enum_declaration(yyast))
    return true;

  yyrewind(start);
  if (parse_static_assert_declaration(yyast))
    return true;

  yyrewind(start);
  if (parse_opaque_enum_declaration(yyast))
    return true;

  yyrewind(start);
  return parse_simple_declaration(yyast, fundef);
};

alias_declaration(DeclarationAST*& yyast): {
  if (!match(TokenKind::T_USING))
    return false;
  if (!match(TokenKind::T_IDENTIFIER))
    return false;
  parse_attribute_specifier_seq();
  if (!match(TokenKind::T_EQUAL))
    return false;
  if (!parse_defining_type_id())
    parse_error("expected a type id");
  expect(TokenKind::T_SEMICOLON);
};

simple_declaration(DeclarationAST*& yyast, bool fundef)
{
  DeclSpecs specs;
  Declarator decl;
}
: __extension__? attribute_specifier_seq?
    ( semicolon
    | decl_specifier_seq_no_typespecs(specs)?
        ( declarator_id attribute_specifier_seq? parameters_and_qualifiers (semicolon | { return fundef; } function_definition_body)
        | decl_specifier_seq(specs)?
          ({ return specs.has_complex_typespec; } semicolon
          |{ return specs.has_typespec(); } ref_qualifier? lbracket identifier_list rbracket initializer semicolon
          |{ return specs.has_typespec(); } declarator(decl)
              ( semicolon
              | { return fundef && isFunctionDeclarator(decl); } function_definition_body
              | declarator_initializer? (comma init_declarator)* semicolon)
              )))
;

function_definition_body: {
  if (parse_requires_clause()) {
    //
  } else {
    parse_virt_specifier_seq();
  }
  return parse_function_body();
};

static_assert_declaration(DeclarationAST*& yyast): {
  if (!match(TokenKind::T_STATIC_ASSERT))
    return false;
  expect(TokenKind::T_LPAREN);
  ExpressionAST* expression = nullptr;
  if (!parse_constant_expression(expression))
    parse_error("expected an expression");
  if (match(TokenKind::T_COMMA)) {
    if (!parse_string_literal_seq())
      parse_error("expected a string literal");
  }
  expect(TokenKind::T_RPAREN);
  expect(TokenKind::T_SEMICOLON);
};

string_literal_seq: {
  if (!match(TokenKind::T_STRING_LITERAL))
    return false;
  while (match(TokenKind::T_STRING_LITERAL)) {
    //
  }
};

empty_declaration(DeclarationAST*& yyast): {
  if (!match(TokenKind::T_SEMICOLON))
    return false;
};

attribute_declaration(DeclarationAST*& yyast): {
  if (!parse_attribute_specifier_seq())
    return false;
  if (!match(TokenKind::T_SEMICOLON))
    return false;
};

decl_specifier(DeclSpecs& specs): {
  switch (yytoken()) {
  case TokenKind::T_FRIEND:
  case TokenKind::T_TYPEDEF:
  case TokenKind::T_CONSTEXPR:
  case TokenKind::T_CONSTEVAL:
  case TokenKind::T_CONSTINIT:
  case TokenKind::T_INLINE:
  case TokenKind::T___INLINE:
  case TokenKind::T___INLINE__:
    yyconsume();
    return true;
  default:
    if (parse_storage_class_specifier())
      return true;
    else if (parse_function_specifier())
      return true;
    else if (!specs.no_typespecs)
      return parse_defining_type_specifier(specs);
    return false;
  } // switch
};

decl_specifier_seq(DeclSpecs& specs): {
  specs.no_typespecs = false;
  if (!parse_decl_specifier(specs))
    return false;
  parse_attribute_specifier_seq();
  while (parse_decl_specifier(specs)) {
    parse_attribute_specifier_seq();
  }
};

decl_specifier_seq_no_typespecs(DeclSpecs& specs): {
  specs.no_typespecs = true;
  if (!parse_decl_specifier(specs))
    return false;
  parse_attribute_specifier_seq();
  while (parse_decl_specifier(specs)) {
    parse_attribute_specifier_seq();
  }
};

storage_class_specifier: {
  switch (yytoken()) {
  default: return false;
  case TokenKind::T_STATIC:
  case TokenKind::T_THREAD_LOCAL:
  case TokenKind::T_EXTERN:
  case TokenKind::T_MUTABLE:
  case TokenKind::T___THREAD:
    yyconsume();
    return true;
  } // switch
};

function_specifier: {
  if (match(TokenKind::T_VIRTUAL))
    return true;
  return parse_explicit_specifier();
};

explicit_specifier: {
  if (!match(TokenKind::T_EXPLICIT))
    return false;
  if (match(TokenKind::T_LPAREN)) {
    ExpressionAST* expression = nullptr;
    if (!parse_constant_expression(expression))
      parse_error("expected a expression");
    expect(TokenKind::T_RPAREN);
  }
};

type_specifier(DeclSpecs& specs): {
  if (parse_simple_type_specifier(specs)) {
    return true;
  } else if (parse_elaborated_type_specifier(specs)) {
    return true;
  } else if (parse_typename_specifier()) {
      specs.has_named_typespec = true;
    return true;
  } else if (parse_cv_qualifier()) {
    return true;
  }
  return false;
};

type_specifier_seq: {
  DeclSpecs specs;
  specs.no_class_or_enum_specs = true;
  if (!parse_type_specifier(specs))
    return false;
  parse_attribute_specifier_seq();
  while (yytoken() != TokenKind::T_EOF_SYMBOL) {
    const auto before_type_specifier = yycursor;
    if (!parse_type_specifier(specs)) {
      yyrewind(before_type_specifier);
      break;
    }
    parse_attribute_specifier_seq();
  }
};

defining_type_specifier(DeclSpecs& specs): {
  if (!specs.no_class_or_enum_specs) {
    const auto start = yycursor;
    if (parse_enum_specifier()) {
      specs.has_complex_typespec = true;
      return true;
    } else if (parse_class_specifier()) {
      specs.has_complex_typespec = true;
      return true;
    }
    yyrewind(start);
  }
  return parse_type_specifier(specs);
};

defining_type_specifier_seq(DeclSpecs& specs): {
  if (!parse_defining_type_specifier(specs))
    return false;
  parse_attribute_specifier_seq();
  while (yytoken() != TokenKind::T_EOF_SYMBOL) {
    const auto before_type_specifier = yycursor;
    if (!parse_defining_type_specifier(specs)) {
      yyrewind(before_type_specifier);
      break;
    }
    parse_attribute_specifier_seq();
  }
};

simple_type_specifier(DeclSpecs& specs)
: primitive_type_specifier(specs)
| underlying_type_specifier(specs)
| atomic_type_specifier(specs)
| named_type_specifier(specs)
| placeholder_type_specifier_helper(specs)
| decltype_specifier_type_specifier(specs)
;

named_type_specifier(DeclSpecs& specs): {
  if (!parse_named_type_specifier_helper(specs))
    return false;
  specs.has_named_typespec = true;
};

named_type_specifier_helper(DeclSpecs& specs): {
  if (specs.has_typespec())
    return false;

  const auto start = yycursor;

  if (parse_nested_name_specifier()) {
    const auto after_nested_name_specifier = yycursor;

    if (match(TokenKind::T_TEMPLATE) && parse_simple_template_id()) {
      return true;
    }

    yyrewind(after_nested_name_specifier);

    if (parse_type_name()) {
      return true;
    }

    yyrewind(after_nested_name_specifier);

    if (parse_template_name()) {
      return true;
    }
  }

  yyrewind(start);

  if (parse_type_name()) {
    return true;
  }

  yyrewind(start);

  if (parse_template_name()) {
    return true;
  }

  return false;
};

placeholder_type_specifier_helper(DeclSpecs& specs): {
  if (specs.has_typespec())
    return false;
  if (!parse_placeholder_type_specifier())
    return false;
  specs.has_placeholder_typespec = true;
};

decltype_specifier_type_specifier(DeclSpecs& specs): {
  if (specs.has_typespec())
    return false;
  if (!parse_decltype_specifier())
    return false;
  specs.has_placeholder_typespec = true;
};

underlying_type_specifier(DeclSpecs& specs): {
  if (specs.has_typespec())
    return false;
  if (!match(TokenKind::T___UNDERLYING_TYPE))
    return false;
  expect(TokenKind::T_LPAREN);
  if (!parse_type_id())
    parse_error("expected type id");
  expect(TokenKind::T_RPAREN);
  specs.has_named_typespec = true;
};

automic_type_specifier(DeclSpecs& specs): {
  if (!specs.accepts_simple_typespec())
    return false;
  if (!match(TokenKind::T__ATOMIC))
    return false;
  expect(TokenKind::T_LPAREN);
  if (!parse_type_id())
    parse_error("expected type id");
  expect(TokenKind::T_RPAREN);
  specs.has_simple_typespec = true;
};

atomic_type_specifier(DeclSpecs& specs): {
  if (!specs.accepts_simple_typespec())
    return false;
  if (!match(TokenKind::T__ATOMIC))
    return false;
  expect(TokenKind::T_LPAREN);
  if (!parse_type_id())
    parse_error("expected type id");
  expect(TokenKind::T_RPAREN);
  specs.has_simple_typespec = true;
};

primitive_type_specifier(DeclSpecs& specs): {
  if (!specs.accepts_simple_typespec())
    return false;
  switch (yytoken()) {
  default: return false;
  case TokenKind::T_CHAR:
  case TokenKind::T_CHAR8_T:
  case TokenKind::T_CHAR16_T:
  case TokenKind::T_CHAR32_T:
  case TokenKind::T_WCHAR_T:
  case TokenKind::T_BOOL:
  case TokenKind::T_SHORT:
  case TokenKind::T_INT:
  case TokenKind::T_LONG:
  case TokenKind::T_SIGNED:
  case TokenKind::T_UNSIGNED:
  case TokenKind::T_FLOAT:
  case TokenKind::T_DOUBLE:
  case TokenKind::T_VOID:
  case TokenKind::T___INT64:
  case TokenKind::T___INT128:
  case TokenKind::T___FLOAT80:
  case TokenKind::T___FLOAT128:
  case TokenKind::T___COMPLEX__:
    yyconsume();
    specs.has_simple_typespec = true;
    return true;
  } // switch
};

type_name
: class_name
| enum_name
| typedef_name
;

elaborated_type_specifier(DeclSpecs& specs): {
  // ### cleanup

  if (yytoken() == TokenKind::T_ENUM)
    return parse_elaborated_enum_specifier();

  if (!parse_class_key())
    return false;

  parse_attribute_specifier_seq();

  const auto before_nested_name_specifier = yycursor;

  if (!parse_nested_name_specifier()) {
    yyrewind(before_nested_name_specifier);

    if (parse_simple_template_id()) {
      specs.has_complex_typespec = true;
      return true;
    }

    yyrewind(before_nested_name_specifier);

    if (!match(TokenKind::T_IDENTIFIER))
      return false;

    specs.has_complex_typespec = true;
    return true;
  }

  const auto after_nested_name_specifier = yycursor;

  const bool has_template = match(TokenKind::T_TEMPLATE);

  if (parse_simple_template_id()) {
    specs.has_complex_typespec = true;
    return true;
  }

  if (has_template) {
    parse_error("expected a template-id");
    specs.has_complex_typespec = true;
    return true;
  }

  yyrewind(after_nested_name_specifier);

  if (!match(TokenKind::T_IDENTIFIER))
    return false;

  specs.has_complex_typespec = true;
  return true;
};

elaborated_enum_specifier
: enum nested_name_specifier? identifier
;

decltype_specifier: {
  if (match(TokenKind::T_DECLTYPE) || match(TokenKind::T___DECLTYPE)
      || match(TokenKind::T___DECLTYPE__)) {
    if (!match(TokenKind::T_LPAREN))
      return false;
    if (yytoken() == TokenKind::T_AUTO)
      return false; // placeholder type specifier
    ExpressionAST* expression = nullptr;
    if (!parse_expression(expression))
      parse_error("expected an expression");
    expect(TokenKind::T_RPAREN);
    return true;
  }

  if (match(TokenKind::T___TYPEOF) || match(TokenKind::T___TYPEOF__)) {
    expect(TokenKind::T_LPAREN);
    ExpressionAST* expression = nullptr;
    if (!parse_expression(expression))
      parse_error("expected an expression");
    expect(TokenKind::T_RPAREN);
    return true;
  }

  return false;
};

placeholder_type_specifier: {
  parse_type_constraint();

  if (match(TokenKind::T_AUTO))
    return true;

  if (match(TokenKind::T_DECLTYPE)) {
    if (!match(TokenKind::T_LPAREN))
      return false;
    if (!match(TokenKind::T_AUTO))
      return false;
    if (!match(TokenKind::T_RPAREN))
      return false;
    return true;
  }

  return false;
};

init_declarator_list: {
  if (!parse_init_declarator())
    return false;
  while (match(TokenKind::T_COMMA)) {
    if (!parse_init_declarator())
      parse_error("expected a declarator");
  }
};

init_declarator: {
  if (!parse_declarator())
    return false;
  const auto saved = yycursor;
  if (!parse_declarator_initializer())
    yyrewind(saved);
};

declarator_initializer: {
  if (parse_requires_clause())
    return true;
  return parse_initializer();
};

declarator(Declarator& decl)
: ptr_operator declarator(decl) { decl.push_back(PtrDeclarator()); }
| noptr_declarator(decl)
;

ptr_operator_seq: {
  if (!parse_ptr_operator())
    return false;
  while (parse_ptr_operator()) {
    //
  }
};

core_declarator(Declarator& decl)
: declarator_id attribute_specifier_seq? { decl.push_back(DeclaratorId()); }
| lparen declarator(decl) rparen { decl.push_back(NestedDeclarator()); }
;

noptr_declarator(Declarator& decl)
{
  ExpressionAST* e1 = nullptr;
}
: core_declarator(decl)
    ( parameters_and_qualifiers trailing_return_type?
        { decl.push_back(FunctionDeclarator()); }
    | lbracket constant_expression(e1)? rbracket attribute_specifier_seq?
        { decl.push_back(ArrayDeclarator()); }
    )*
;

parameters_and_qualifiers: {
  if (!match(TokenKind::T_LPAREN))
    return false;
  DeclarativeRegion::Context region(this);
  parse_enter(region);
  if (!match(TokenKind::T_RPAREN)) {
    if (!parse_parameter_declaration_clause())
      return false;
    if (!match(TokenKind::T_RPAREN))
      return false;
  }
  parse_cv_qualifier_seq();
  parse_ref_qualifier();
  parse_noexcept_specifier();
  parse_attribute_specifier_seq();
  return true;
};

cv_qualifier_seq
: cv_qualifier+;

trailing_return_type
: minus_greater type_id
;

ptr_operator
: star attribute_specifier_seq? cv_qualifier_seq?
| amp attribute_specifier_seq?
| amp_amp attribute_specifier_seq?
| nested_name_specifier star attribute_specifier_seq? cv_qualifier_seq?
;

cv_qualifier
: const
| volatile
| __restrict
| __restrict__
;

ref_qualifier
: amp
| amp_amp
;

declarator_id
: dot_dot_dot? id_expression
;

type_id
: type_specifier_seq abstract_declarator?
;

defining_type_id
{
  DeclSpecs specs;
  specs.no_class_or_enum_specs = true;
}
: defining_type_specifier_seq(specs) abstract_declarator?
;

abstract_declarator
: noptr_abstract_declarator? parameters_and_qualifiers trailing_return_type
| abstract_pack_declarator
| ptr_abstract_declarator
;

ptr_abstract_declarator
: ptr_operator_seq? noptr_abstract_declarator
;

noptr_abstract_declarator
{
  ExpressionAST* e1 = nullptr;
}
: (lparen ptr_abstract_declarator rparen)?
    ( parameters_and_qualifiers
    | lbracket constant_expression(e1)? rbracket attribute_specifier_seq?)*
;

abstract_pack_declarator
: ptr_operator_seq? noptr_abstract_pack_declarator
;

noptr_abstract_pack_declarator
{
  ExpressionAST* e1 = nullptr;
}
: dot_dot_dot
    ( parameters_and_qualifiers
    | lbracket constant_expression(e1)? rbracket attribute_specifier_seq?)*
;

parameter_declaration_clause0
: parameter_declaration_list comma? dot_dot_dot?
| dot_dot_dot?
;

parameter_declaration_clause: {
  if (match(TokenKind::T_DOT_DOT_DOT))
    return true;
  if (!parse_parameter_declaration_list())
    return false;
  match(TokenKind::T_COMMA);
  match(TokenKind::T_DOT_DOT_DOT);
};

parameter_declaration_list: {
  if (!parse_parameter_declaration())
    return false;
  while (match(TokenKind::T_COMMA)) {
    if (!parse_parameter_declaration()) {
      yyrewind(yycursor - 1);
      break;
    }
  }
};

parameter_declaration0
{
  DeclSpecs specs;
  specs.no_class_or_enum_specs = true;

  ExpressionAST* e1 = nullptr;
}
: attribute_specifier_seq? decl_specifier_seq(specs)
    ( declarator (equal initializer_clause(e1))?
    | abstract_declarator? (equal initializer_clause(e1))?)
;

parameter_declaration: {
  parse_attribute_specifier_seq();

  DeclSpecs specs;
  specs.no_class_or_enum_specs = true;

  if (!parse_decl_specifier_seq(specs))
    return false;

  const auto before_declarator = yycursor;

  if (!parse_declarator()) {
    yyrewind(before_declarator);
    if (!parse_abstract_declarator())
      yyrewind(before_declarator);
  }

  if (match(TokenKind::T_EQUAL)) {
    ExpressionAST* expression = nullptr;
    if (!parse_initializer_clause(expression))
      parse_error("expected an initializer");
  }

  return true;
};

initializer: {
  if (match(TokenKind::T_LPAREN)) {
    if (!parse_expression_list())
      parse_error("expected an expression");
    expect(TokenKind::T_RPAREN);
    return true;
  }
  return parse_brace_or_equal_initializer();
};

brace_or_equal_initializer: {
  if (yytoken() == TokenKind::T_LBRACE)
    return parse_braced_init_list();
  if (!match(TokenKind::T_EQUAL))
    return false;
  ExpressionAST* expression = nullptr;
  if (!parse_initializer_clause(expression))
    parse_error("expected an intializer");
};

initializer_clause(ExpressionAST*& yyast): {
  if (yytoken() == TokenKind::T_LBRACE)
    return parse_braced_init_list();
  return parse_assignment_expression(yyast);
};

braced_init_list: {
  if (!match(TokenKind::T_LBRACE)) return false;

  if (yytoken() == TokenKind::T_DOT) {
    if (!parse_designated_initializer_clause())
      parse_error("expected designated initializer clause");

    while (match(TokenKind::T_COMMA)) {
      if (yytoken() == TokenKind::T_RBRACE) break;

      if (!parse_designated_initializer_clause())
        parse_error("expected designated initializer clause");
    }
  } else if (match(TokenKind::T_COMMA)) {
    // nothing to do
  } else if (yytoken() != TokenKind::T_RBRACE) {
    if (!parse_initializer_list())
      parse_error("expected initializer list");
  }

  expect(TokenKind::T_RBRACE);
};

initializer_list: {
  ExpressionAST* e = nullptr;

  if (!parse_initializer_clause(e))
    return false;

  bool has_triple_dot = false;
    if (match(TokenKind::T_DOT_DOT_DOT)) {
    has_triple_dot = true;
  }

  while (match(TokenKind::T_COMMA)) {
    if (yytoken() == TokenKind::T_RBRACE) break;

    ExpressionAST* e = nullptr;
    if (!parse_initializer_clause(e))
      parse_error("expected initializer clause");

    bool has_triple_dot = false;
    if (match(TokenKind::T_DOT_DOT_DOT)) {
      has_triple_dot = true;
    }
  }
};

designated_initializer_clause: {
  if (!parse_designator())
    return false;
  if (!parse_brace_or_equal_initializer())
    parse_error("expected an initializer");
};

designator
: dot identifier
;

expr_or_braced_init_list: {
  if (yytoken() == TokenKind::T_LBRACE)
    return parse_braced_init_list();
  ExpressionAST* expression = nullptr;
  if (!parse_expression(expression))
    parse_error("expected an expression");
};

virt_specifier_seq: {
  if (!parse_virt_specifier())
    return false;
  while (parse_virt_specifier()) {
    //
  }
};

function_body: {
  if (yytoken() == TokenKind::T_SEMICOLON)
    return false;

  if (parse_function_try_block())
    return true;
  else if (match(TokenKind::T_EQUAL)) {
    if (match(TokenKind::T_DEFAULT)) {
      expect(TokenKind::T_SEMICOLON);
      return true;
    } else if (match(TokenKind::T_DELETE)) {
      expect(TokenKind::T_SEMICOLON);
      return true;
    }
    return false;
  }

  parse_ctor_initializer();

  if (yytoken() != TokenKind::T_LBRACE)
    return false;

  if (skip_function_body) {
    expect(TokenKind::T_LBRACE);
    int depth = 1;
    TokenKind tok;
    while ((tok = yytoken()) != TokenKind::T_EOF_SYMBOL) {
      if (tok == TokenKind::T_LBRACE) {
        ++depth;
      } else if (tok == TokenKind::T_RBRACE) {
        if (!--depth) {
          break;
        }
      }
      yyconsume();
    }
    expect(TokenKind::T_RBRACE);
  }

  StatementAST* statement = nullptr;
  if (!parse_compound_statement(statement))
    parse_error("expected a compound statement");
};

enum_specifier: {
  if (!parse_enum_head())
    return false;
  if (!match(TokenKind::T_LBRACE))
    return false;
  if (!match(TokenKind::T_RBRACE)) {
    DeclarativeRegion::Context region(this);
    parse_enter(region);
    parse_enumerator_list();
    match(TokenKind::T_COMMA);
    expect(TokenKind::T_RBRACE);
  }
};

enum_head: {
  if (!parse_enum_key())
    return false;
  parse_attribute_specifier_seq();
  parse_enum_head_name();
  parse_enum_base();
};

enum_head_name: {
  auto start = yycursor;
  if (!parse_nested_name_specifier())
    yyrewind(start);
  if (!match(TokenKind::T_IDENTIFIER))
    return false;
};

opaque_enum_declaration(DeclarationAST*& yyast): {
  if (!parse_enum_key())
    return false;
  parse_attribute_specifier_seq();
  if (!parse_enum_head_name())
    return false;
  parse_enum_base();
  if (!match(TokenKind::T_SEMICOLON))
    return false;
};

enum_key: {
  if (!match(TokenKind::T_ENUM))
    return false;
  if (match(TokenKind::T_CLASS)) {
    //
  } else if (match (TokenKind::T_STRUCT)) {
    //
  }
};

enum_base: {
  if (!match(TokenKind::T_COLON))
    return false;
  if (!parse_type_specifier_seq())
    parse_error("expected a type specifier");
};

enumerator_list: {
  if (!parse_enumerator_definition())
    return false;
  while (match(TokenKind::T_COMMA)) {
    if (yytoken() == TokenKind::T_RBRACE) {
      yyrewind(yycursor - 1);
      break;
    }
    if (!parse_enumerator_definition())
      parse_error("expected an enumerator");
  }
};

enumerator_definition: {
  if (!parse_enumerator())
    return false;
  if (match(TokenKind::T_EQUAL)) {
    ExpressionAST* expression = nullptr;
    if (!parse_constant_expression(expression))
      parse_error("expected an expression");
  }
};

enumerator: {
  if (!match(TokenKind::T_IDENTIFIER))
    return false;
  parse_attribute_specifier_seq();
};

using_enum_declaration(DeclarationAST*& yyast): {
  if (!match(TokenKind::T_USING))
    return false;
  if (!parse_elaborated_enum_specifier())
    return false;
  if (!match(TokenKind::T_SEMICOLON))
    return false;
};

namespace_definition(DeclarationAST*& yyast)
: nested_namespace_definition(yyast)
| named_namespace_definition(yyast)
| unnamed_namespace_definition(yyast)
;

named_namespace_definition(DeclarationAST*& yyast): {
  bool has_inline = false;

  if (match(TokenKind::T_INLINE)) {
    has_inline = true;
  }

  if (!match(TokenKind::T_NAMESPACE))
    return false;

  parse_attribute_specifier_seq();

  if (!match(TokenKind::T_IDENTIFIER))
    return false;

  auto name = yycursor - 1;

  parse_gcc_attribute_seq();

  expect(TokenKind::T_LBRACE);
  DeclarativeRegion::Context context(this);
  parse_enter_named_namespace_definition(context, name);
  parse_namespace_body();
  expect(TokenKind::T_RBRACE);
};

enter_named_namespace_definition(DeclarativeRegion::Context& context, uint32_t& name):
{
  const auto id = Name(unit->identifier(name));
  Symbol* ns = currentRegion_->scope.find(id);
  for (; ns; ns = ns->next) {
    if (ns->name == id && ns->isNamespace())
      break;
  }
  if (!ns) {
    ns = newSymbol();
    ns->name = id;
    NamespaceData data;
    data.region = newDeclarativeRegion(currentRegion_);
    ns->data = data;
    currentRegion_->scope.add(ns);
  }
  context.enter(std::get<NamespaceData>(ns->data).region);
};

unnamed_namespace_definition(DeclarationAST*& yyast): {
  bool has_inline = false;
  if (match(TokenKind::T_INLINE))
    has_inline = true;
  if (!match(TokenKind::T_NAMESPACE))
    return false;
  parse_attribute_specifier_seq();
  parse_gcc_attribute_seq();
  if (!match(TokenKind::T_LBRACE))
    return false;
  DeclarativeRegion::Context region(this);
  parse_enter_unnamed_namespace_definition(region);
  parse_namespace_body();
  expect(TokenKind::T_RBRACE);
};

enter_unnamed_namespace_definition(DeclarativeRegion::Context& region):
{
  auto ns = newSymbol();
  NamespaceData data;
  data.region = newDeclarativeRegion(currentRegion_);
  ns->data = data;
  currentRegion_->scope.add(ns);
};

nested_namespace_definition(DeclarationAST*& yyast): {
  if (!match(TokenKind::T_NAMESPACE))
    return false;
  if (!parse_enclosing_namespace_specifier())
    return false;
  if (!match(TokenKind::T_COLON_COLON))
    return false;
  bool has_inline = false;
  if (match(TokenKind::T_INLINE))
    has_inline = true;
  if (!match(TokenKind::T_IDENTIFIER))
    return false;
  parse_gcc_attribute_seq();
  if (!match(TokenKind::T_LBRACE))
    return false;
  DeclarativeRegion::Context region(this);
  parse_enter(region);
  parse_namespace_body();
  expect(TokenKind::T_RBRACE);
};

enclosing_namespace_specifier
: identifier (colon_colon inline?
    identifier / (colon_colon inline? identifier))*
;

namespace_body: {
  bool skipping = false;
  while (yytoken() != TokenKind::T_EOF_SYMBOL) {
    if (yytoken() == TokenKind::T_RBRACE) break;
    const auto saved = yycursor;
    DeclarationAST* decl = nullptr;
    if (parse_declaration(decl)) {
      skipping = false;
    } else {
      parse_skip_declaration(skipping);
      if (yycursor == saved)
        yyconsume();
    }
  }
};

namespace_alias_definition(DeclarationAST*& yyast): {
  if (!match(TokenKind::T_NAMESPACE))
    return false;
  expect(TokenKind::T_IDENTIFIER);
  expect(TokenKind::T_EQUAL);
  if (!parse_qualified_namespace_specifier())
    parse_error("expected a namespace name");
  expect(TokenKind::T_SEMICOLON);
};

qualified_namespace_specifier
: nested_name_specifier? namespace_name
;

using_directive(DeclarationAST*& yyast): {
  parse_attribute_specifier_seq();
  if (!match(TokenKind::T_USING))
    return false;
  if (!match(TokenKind::T_NAMESPACE))
    return false;
  auto saved = yycursor;
  if (!parse_nested_name_specifier())
    yyrewind(saved);
  if (!parse_namespace_name())
    parse_error("expected a namespace name");
  expect(TokenKind::T_SEMICOLON);
};

using_declaration(DeclarationAST*& yyast): {
   if (!match(TokenKind::T_USING))
    return false;
  if (!parse_using_declarator_list())
    parse_error("expected a using declarator");
  match(TokenKind::T_SEMICOLON);
};

using_declarator_list
: using_declarator dot_dot_dot? (comma using_declarator dot_dot_dot?)*
;

using_declarator
: typename? nested_name_specifier unqualified_id
;

asm_declaration(DeclarationAST*& yyast): {
  parse_attribute_specifier_seq();
  if (!match(TokenKind::T_ASM))
    return false;
  expect(TokenKind::T_LPAREN);
  while (match(TokenKind::T_STRING_LITERAL)) {
  }
  expect(TokenKind::T_RPAREN);
  expect(TokenKind::T_SEMICOLON);
};

linkage_specification(DeclarationAST*& yyast)
{
  DeclarationAST* d1 = nullptr;
}
: extern string_literal lbrace declaration_seq? rbrace
| extern string_literal declaration(d1)
;

attribute_specifier_seq
: attribute_specifier+
;

attribute_specifier
: gcc_attribute
| lbracket lbracket attribute_using_prefix? attribute_list rbracket rbracket
| alignment_specifier
| (__asm | __asm__) lparen string_literal_seq rparen
;

gcc_attribute
: (__attribute | __attribute__) lparen skip_balanced rparen
;

gcc_attribute_seq
: gcc_attribute+
;

skip_balanced
: {
  int count = 1;
  TokenKind tk;
  while ((tk = yytoken()) != TokenKind::T_EOF_SYMBOL) {
    if (tk == TokenKind::T_LPAREN) {
      ++count;
    } else if (tk == TokenKind::T_RPAREN) {
      if (!--count) {
        return true;
      }
    }
    yyconsume();
  }
  return false;
};

alignment_specifier
{
  ExpressionAST* e1 = nullptr;
}
: alignas lparen type_id dot_dot_dot? rparen
| alignas lparen constant_expression(e1) dot_dot_dot? rparen
;

attribute_using_prefix
: using attribute_namespace colon
;

attribute_list
: (attribute dot_dot_dot? | attribute?)
    (comma attribute? | attribute dot_dot_dot?)*
;

attribute
: attribute_token attribute_argument_clause?
;

attribute_token
: attribute_scoped_token
| identifier
;

attribute_scoped_token
: attribute_namespace colon_colon identifier
;

attribute_namespace
: identifier
;

attribute_argument_clause
: lparen skip_balanced rparen
;

module_declaration
: export_keyword? module_keyword module_name module_partition? attribute_specifier_seq? semicolon
;

module_name
: module_name_qualifier? identifier
;

module_partition
: colon module_name_qualifier? identifier
;

module_name_qualifier
: identifier dot (identifier dot)*
;

export_declaration(DeclarationAST*& yyast)
{
  DeclarationAST* d1 = nullptr;
}
: export declaration(d1)
| export lbrace declaration_seq? rbrace
| export_keyword module_import_declaration(d1)
;

module_import_declaration(DeclarationAST*& yyast)
: import_keyword module_name attribute_specifier_seq? semicolon
| import_keyword module_partition attribute_specifier_seq? semicolon
| import_keyword header_name attribute_specifier_seq? semicolon
;

global_module_fragment
: module_keyword semicolon declaration_seq?
;

private_module_fragment
: module_keyword colon private semicolon declaration_seq?
;

class_specifier: {
  const auto start = yycursor;
  auto it = class_specifiers_.find(start);
  if (it != class_specifiers_.end()) {
    auto [cursor, parsed] = it->second;
    yyrewind(cursor);
    return parsed;
  }
  DeclarativeRegion::Context region(this);

  DeclarativeRegion* enclosingRegion = nullptr;

  Symbol* classSymbol = nullptr;
  Name className;

  if (!parse_class_head(enclosingRegion, className)) {
    parse_reject_class_specifier(start);
    return false;
  }
  if (!match(TokenKind::T_LBRACE)) {
    parse_reject_class_specifier(start);
    return false;
  }
  parse_enter_class_specifier(region, enclosingRegion, className, classSymbol);
  if (!match(TokenKind::T_RBRACE)) {
    if (!parse_class_body())
      parse_error("expected class body");
    expect(TokenKind::T_RBRACE);
  }
  parse_leave_class_specifier(classSymbol, start);
};

enter_class_specifier(DeclarativeRegion::Context& region, DeclarativeRegion* enclosingRegion, Name& className, Symbol*& classSymbol):
{
  if (!enclosingRegion) {
    unit->report(yycursor, MessageKind::Error, "unresolved nested name specifier");
    enclosingRegion = currentRegion_;
  }

  classSymbol = newSymbol();
  classSymbol->name = className;
  enclosingRegion->scope.add(classSymbol);

  ClassData classData;
  classData.lexicalRegion = currentRegion_;
  classData.region = newDeclarativeRegion(enclosingRegion);
  classSymbol->data = classData;
  region.enter(classData.region);
};

leave_class_specifier(Symbol* classSymbol, uint32_t start):
{
  get_if<ClassData>(&classSymbol->data)->isComplete = true;
  class_specifiers_.emplace(start, std::make_tuple(yycursor, true));
};

reject_class_specifier(uint32_t start):
{
  class_specifiers_.emplace(start, std::make_tuple(yycursor, false));
  return false;
};

class_body: {
  bool skipping = false;
  while (yytoken() != TokenKind::T_EOF_SYMBOL) {
    if (yytoken() == TokenKind::T_RBRACE)
      break;
    auto saved = yycursor;
    DeclarationAST* declaration = nullptr;
    if (parse_member_specification(declaration)) {
      skipping = false;
    } else {
      if (!skipping)
        unit->report(yycursor, MessageKind::Error, "expected a declaration");
      if (yycursor == saved)
        yyconsume();
      skipping = true;
    }
  }
};

class_head(DeclarativeRegion*& region, Name& name)
: class_key attribute_specifier_seq?
  (class_head_name(region, name) class_virt_specifier?)?
  base_clause?
;

class_head_name(DeclarativeRegion*& region, Name& name)
: nested_name_specifier(region) class_name(name)
| class_name(name) { region = currentRegion_; }
;

class_virt_specifier
: final
;

class_key
: class
| struct
| union
;

member_specification(DeclarationAST*& yyast)
: member_declaration(yyast)
;

member_declaration(DeclarationAST*& yyast)
{
  DeclSpecs specs;
  Declarator decl;
}
: access_specifier colon
| __extension__? attribute_specifier_seq? decl_specifier_seq_no_typespecs(specs)?
        ( declarator_id attribute_specifier_seq? parameters_and_qualifiers
            ( member_function_definition_body
            | member_declarator_modifier semicolon)
        | decl_specifier_seq(specs)? { return specs.has_typespec(); }
            ( semicolon
            | declarator(decl) { return isFunctionDeclarator(decl); } member_function_definition_body
            | member_declarator_list semicolon))
| empty_declaration(yyast)
| using_enum_declaration(yyast)
| alias_declaration(yyast)
| using_declaration(yyast)
| static_assert_declaration(yyast)
| template_declaration(yyast)
| explicit_specialization(yyast)
| deduction_guide(yyast)
| opaque_enum_declaration(yyast)
;

member_function_definition_body
: (requires_clause | virt_specifier_seq?) function_body
;

member_declarator_modifier
: requires_clause
| brace_or_equal_initializer
| virt_specifier_seq? pure_specifier?
;

member_declarator_list
: member_declarator (comma member_declarator)*
;

member_declarator
{
  ExpressionAST* e1 = nullptr;
}
: identifier? attribute_specifier_seq? colon constant_expression(e1) brace_or_equal_initializer?
| declarator member_declarator_modifier
;

virt_specifier
: override
| final
;

pure_specifier
: equal integer_literal
;

conversion_function_id
: operator conversion_type_id
;

conversion_type_id
: type_specifier_seq conversion_declarator?
;

conversion_declarator
: ptr_operator conversion_declarator?
;

base_clause
: colon base_specifier_list
;

base_specifier_list
: base_specifier dot_dot_dot? (comma base_specifier dot_dot_dot?)*
;

base_specifier
: attribute_specifier_seq? (virtual access_specifier? | access_specifier virtual?)? class_or_decltype
;

class_or_decltype
: nested_name_specifier ( template simple_template_id
                        | type_name)
| decltype_specifier
| type_name
;

access_specifier
: private
| protected
| public
;

ctor_initializer: {
  if (!match(TokenKind::T_COLON))
    return false;
  if (!parse_mem_initializer_list())
    parse_error("expected a member intializer");
};

mem_initializer_list: {
  if (!parse_mem_initializer())
    return false;
  match(TokenKind::T_DOT_DOT_DOT);
  while (match(TokenKind::T_COMMA)) {
    if (!parse_mem_initializer())
      parse_error("expected a member initializer");
    match(TokenKind::T_DOT_DOT_DOT);
  }
};

mem_initializer: {
  if (!parse_mem_initializer_id())
    parse_error("expected an member id");
  if (yytoken() == TokenKind::T_LBRACE) {
    if (!parse_braced_init_list())
      parse_error("expected an initializer");
  } else {
    expect(TokenKind::T_LPAREN);
    if (!match(TokenKind::T_RPAREN)) {
      if (!parse_expression_list())
        parse_error("expected an expression");
      expect(TokenKind::T_RPAREN);
    }
  }
};

mem_initializer_id
: class_or_decltype
| identifier
;

operator_function_id
: operator op
;

op
: new lbracket rbracket
| delete lbracket rbracket
| new
| delete
| co_await
| lparen rparen
| lbracket rbracket
| minus_greater
| minus_greater_star
| tilde
| exclaim
| plus
| minus
| star
| slash
| percent
| caret
| amp
| bar
| equal
| plus_equal
| minus_equal
| star_equal
| slash_equal
| percent_equal
| caret_equal
| amp_equal
| bar_equal
| equal_equal
| exclaim_equal
| less
| less_equal
| greater_greater_equal
| greater_greater
| greater_equal
| greater
| less_equal_greater
| amp_amp
| bar_bar
| less_less
| less_less_equal
| plus_plus
| minus_minus
| comma
;

literal_operator_id
: operator string_literal identifier
| operator user_defined_string_literal
;

template_declaration(DeclarationAST*& yyast): {
  if (!parse_template_head())
    return false;
  if (yytoken() == TokenKind::T_CONCEPT) {
    parse_concept_definition();
  } else {
    DeclarationAST* declaration = nullptr;
    if (!parse_declaration(declaration))
      parse_error("expected a declaration");
  }
};

template_head: {
  if (!match(TokenKind::T_TEMPLATE))
    return false;
  if (!match(TokenKind::T_LESS))
    return false;
  DeclarativeRegion::Context region(this);
  parse_enter(region);
  if (!match(TokenKind::T_GREATER)) {
    if (!parse_template_parameter_list())
      parse_error("expected a template parameter");
    expect(TokenKind::T_GREATER);
  }
  parse_requires_clause();
};

template_parameter_list: {
  if (!parse_template_parameter())
    return false;
  while (match(TokenKind::T_COMMA)) {
    if (!parse_template_parameter())
      parse_error("expected a template parameter");
  }
};

requires_clause
{
  ExpressionAST* e1 = nullptr;
}
: requires constraint_logical_or_expression(e1)
;

constraint_logical_or_expression(ExpressionAST*& yyast)
{
  ExpressionAST* e1 = nullptr;
}
: constraint_logical_and_expression(yyast) (bar_bar constraint_logical_and_expression(e1))*
;

constraint_logical_and_expression(ExpressionAST*& yyast)
{
  ExpressionAST* e1 = nullptr;
}
: primary_expression(yyast) (amp_amp primary_expression(e1))*
;

template_parameter
: type_parameter / (comma | greater)
| parameter_declaration
;

type_parameter
: type_parameter_key identifier? equal type_id
| type_parameter_key dot_dot_dot? identifier?
| type_constraint identifier? equal type_id
| type_constraint dot_dot_dot? identifier?
| template_head type_parameter_key identifier? equal id_expression
| template_head type_parameter_key dot_dot_dot? identifier?
;

type_parameter_key
: class
| typename
;

type_constraint: {
  const auto start = yycursor;
  if (!parse_nested_name_specifier())
    yyrewind(start);
  if (!parse_concept_name()) {
    yyrewind(start);
    return false;
  }
  if (match(TokenKind::T_LESS)) {
    if (!parse_template_argument_list())
      parse_error("expected a template argument");
    expect(TokenKind::T_GREATER);
  }
};

simple_template_id
{
  Name name;
}
: simple_template_id(name)
;

simple_template_id(Name& name)
: template_name(name) less template_argument_list? greater
    { name = control->getTemplateId(name); }
;

template_id
: operator_function_id less template_argument_list? greater
| literal_operator_id less template_argument_list? greater
| simple_template_id
;

template_argument_list: {
  TemplArgContext templArgContext(this);
  if (!parse_template_argument())
    return false;
  match(TokenKind::T_DOT_DOT_DOT);
  while (match(TokenKind::T_COMMA)) {
    if (!parse_template_argument()) {
      //parse_error("expected a template argument"); // ### FIXME
    }
    match(TokenKind::T_DOT_DOT_DOT);
  }
};

template_argument: {
  const auto start = yycursor;
  auto it = template_arguments_.find(start);
  if (it != template_arguments_.end()) {
    yyrewind(get<0>(it->second));
    return get<1>(it->second);
  }

  auto check = [&]() -> bool {
    auto tk = yytoken();
    return tk == TokenKind::T_COMMA ||
      tk == TokenKind::T_GREATER ||
      tk == TokenKind::T_DOT_DOT_DOT;
  };
  const auto saved = yycursor;
  if (parse_type_id() && check()) {
    template_arguments_.emplace(start, std::make_tuple(yycursor, true));
    return true;
  }
  yyrewind(saved);
  ExpressionAST* expression = nullptr;
  auto parsed = parse_template_argument_constant_expression(expression);
  if (parsed && check()) {
    template_arguments_.emplace(start, std::make_tuple(yycursor, true));
    return true;
  }
  template_arguments_.emplace(start, std::make_tuple(yycursor, false));
  return false;
};

constraint_expression(ExpressionAST*& yyast)
: logical_or_expression(yyast, false)
;

deduction_guide(DeclarationAST*& yyast)
: explicit_specifier? template_name lparen parameter_declaration_clause rparen minus_greater simple_template_id semicolon
;

concept_definition: {
  if (!match(TokenKind::T_CONCEPT))
    return false;
  if (!parse_concept_name())
    parse_error("expected a concept name");
  expect(TokenKind::T_EQUAL);
  ExpressionAST* expression = nullptr;
  if (!parse_constraint_expression(expression))
    parse_error("expected a constraint expression");
  expect(TokenKind::T_SEMICOLON);
};

concept_name
: identifier
;

typename_specifier
: typename nested_name_specifier (template? simple_template_id | identifier)
;

explicit_instantiation(DeclarationAST*& yyast): {
  const auto has_extern = match(TokenKind::T_EXTERN);
  if (!match(TokenKind::T_TEMPLATE))
    return false;
  if (yytoken() == TokenKind::T_LESS)
    return false;
  DeclarationAST* declaration = nullptr;
  if (!parse_declaration(declaration))
    parse_error("expected a declaration");
};

explicit_specialization(DeclarationAST*& yyast): {
  if (!match(TokenKind(TokenKind::T_TEMPLATE)))
    return false;
  if (!match(TokenKind::T_LESS))
    return false;
  if (!match(TokenKind::T_GREATER))
    return false;
  DeclarationAST* declaration = nullptr;
  if (!parse_declaration(declaration))
    parse_error("expected a declaration");
};

try_block(StatementAST*& yyast): {
  if (!match(TokenKind::T_TRY))
    return false;
  StatementAST* statement = nullptr;
  if (!parse_compound_statement(statement))
    parse_error("expected a compound statement");
  if (!parse_handler_seq())
    parse_error("expected an exception handler");
};

function_try_block: {
  if (!match(TokenKind::T_TRY))
    return false;
  if (yytoken() != TokenKind::T_LBRACE) {
    if (!parse_ctor_initializer())
      parse_error("expected a ctor initializer");
  }
  StatementAST* statement = nullptr;
  if (!parse_compound_statement(statement))
    parse_error("expected a compound statement");
  if (!parse_handler_seq())
    parse_error("expected an exception handler");
};

handler: {
  StatementAST* s1 = nullptr;
  if (!match(TokenKind::T_CATCH))
    return false;
  expect(TokenKind::T_LPAREN);
  if (!parse_exception_declaration())
    parse_error("expected an exception declaration");
  expect(TokenKind::T_RPAREN);
  StatementAST* statement = nullptr;
  if (!parse_compound_statement(statement))
    parse_error("expected a compound statement");
};

handler_seq: {
  if (yytoken() != TokenKind::T_CATCH)
    return false;
  while (yytoken() == TokenKind::T_CATCH) {
    parse_handler();
  }
};

exception_declaration: {
  if (match(TokenKind::T_DOT_DOT_DOT))
    return true;
  parse_attribute_specifier_seq();
  if (!parse_type_specifier_seq())
    parse_error("expected a type specifier");
  if (yytoken() == TokenKind::T_RPAREN)
    return true;
  auto before_declarator = yycursor;
  if (!parse_declarator())
    yyrewind(before_declarator);
  else if (!parse_abstract_declarator())
    parse_error("expected a declarator");
};

noexcept_specifier: {
  if (match(TokenKind::T_THROW)) {
    expect(TokenKind::T_LPAREN);
    expect(TokenKind::T_RPAREN);
    return true;
  }

  if (!match(TokenKind::T_NOEXCEPT))
    return false;

  if (match(TokenKind::T_LPAREN)) {
    ExpressionAST* expression = nullptr;

    if (!parse_constant_expression(expression))
      parse_error("expected a declaration");

    expect(TokenKind::T_RPAREN);
  }
};

identifier_list: {
  if (!match(TokenKind::T_IDENTIFIER))
    return false;
  while (match(TokenKind::T_COMMA)) {
    expect(TokenKind::T_IDENTIFIER);
  }
};
